<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Image Color Quantizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .custom-file-button input[type="file"] {
            display: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5;
            /* indigo-600 */
            cursor: pointer;
            border-radius: 50%;
            transition: background .2s;
        }

        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5;
            /* indigo-600 */
            cursor: pointer;
            border-radius: 50%;
            border: 0;
        }

        input[type=range]:disabled::-webkit-slider-thumb {
            background: #9ca3af;
            /* gray-400 */
        }

        input[type=range]:disabled::-moz-range-thumb {
            background: #9ca3af;
            /* gray-400 */
        }

        .palette-swatch {
            width: 100%;
            padding-top: 100%;
            /* 1:1 Aspect Ratio */
            position: relative;
            border-radius: 0.5rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
            cursor: pointer;
            overflow: hidden;
        }

        .palette-swatch span {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.8);
            color: #1f2937;
            transition: opacity 0.2s;
        }

        #analysisTableContainer {
            max-height: 400px;
            overflow-y: auto;
        }

        #customColorPicker {
            position: absolute;
            z-index: 1000;
        }

        #nativeColorPickerInCustom {
            width: 100%;
            height: 40px;
            border: 1px solid #ccc;
            border-radius: 0.5rem;
            cursor: pointer;
            padding: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        #nativeColorPickerInCustom::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        #nativeColorPickerInCustom::-webkit-color-swatch {
            border: none;
            border-radius: 0.5rem;
        }

        #nativeColorPickerInCustom::-moz-color-swatch {
            border: none;
            border-radius: 0.5rem;
        }

        .delta-positive {
            color: #16a34a;
        }

        /* green-600 */
        .delta-negative {
            color: #dc2626;
        }

        /* red-600 */

        /* Drag and Drop styles */
        .drag-over {
            border: 2px dashed #6366f1;
            /* indigo-500 */
            background-color: #eef2ff;
            /* indigo-50 */
        }

        /* Pixel art rendering for canvases */
        canvas {
            image-rendering: optimizeSpeed;
            /* Older, less precise */
            image-rendering: -moz-crisp-edges;
            /* Firefox */
            image-rendering: -webkit-optimize-contrast;
            /* Webkit (Safari, Chrome) */
            image-rendering: optimize-contrast;
            /* CSS3 */
            image-rendering: pixelated;
            /* CSS4 */
            -ms-interpolation-mode: nearest-neighbor;
            /* IE (non-standard) */
        }
    </style>
</head>

<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">

    <div id="appContainer" class="w-full max-w-5xl bg-white rounded-xl shadow-lg p-6 md:p-8">
        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Advanced Color Quantizer</h1>
            <p class="text-gray-600 mt-2">Reduce colors, view palettes, and measure image quality with PSNR.</p>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6 items-end">
            <div class="flex flex-col">
                <label for="imageUpload" class="mb-2 font-semibold text-gray-700">1. Upload Image</label>
                <div class="custom-file-button">
                    <label for="imageUpload"
                        class="w-full inline-flex items-center justify-center px-4 py-2 bg-gray-200 text-gray-700 rounded-lg cursor-pointer hover:bg-gray-300 transition-colors">
                        <!-- SVG code has been removed from here -->
                        <span id="fileName">Choose a PNG file...</span>
                    </label>
                    <input id="imageUpload" type="file" accept="image/png">
                </div>
                <p class="text-sm text-gray-500 mt-2">Or drag & drop / paste a PNG image anywhere on the page.</p>
            </div>
            <div class="flex flex-col">
                <label for="colorSlider" class="mb-2 font-semibold text-gray-700">2. Number of Colors</label>
                <div class="flex items-center space-x-4">
                    <input id="colorSlider" type="range" min="2" max="256" value="16"
                        class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer" disabled>
                    <span id="sliderValue"
                        class="font-semibold text-gray-700 w-16 text-center bg-gray-100 rounded-md py-1">16</span>
                </div>
            </div>
        </div>

        <!-- Algorithm Selection Dropdown -->
        <div class="mb-6">
            <label for="algorithmSelect" class="block mb-2 font-semibold text-gray-700">3. Select Algorithm</label>
            <select id="algorithmSelect"
                class="block w-full px-4 py-2 bg-white border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-200 disabled:cursor-not-allowed">
                <option value="median-cut">Median Cut - A simple default algorithm</option>
                <option value="k-means">K-Means Clustering - More performant</option>
                <option value="neuquant">NeuQuant - Produces a small output and works fast for large images</option>
                <option value="octree">Octree Quantization - Higher quality and works for large images</option>
            </select>
        </div>


        <div id="status" class="text-center my-4 text-lg text-gray-600 h-6"></div>

        <div id="resultContainer" class="grid grid-cols-1 md:grid-cols-2 gap-8 hidden">
            <div>
                <h2 class="text-xl font-semibold text-center mb-4">Original Image <span id="originalImageSize"
                        class="text-base text-gray-500 font-normal"></span></h2>
                <canvas id="originalCanvas" class="w-full h-auto rounded-lg shadow-md border border-gray-200"></canvas>
            </div>
            <div>
                <h2 class="text-xl font-semibold text-center mb-4">Quantized Image <span id="quantizedImageSize"
                        class="text-base text-gray-500 font-normal"></span></h2>
                <canvas id="quantizedCanvas" class="w-full h-auto rounded-lg shadow-md border border-gray-200"></canvas>
                <!-- PSNR (Quality) widget moved here -->
                <div class="mt-4 bg-gray-50 p-4 rounded-lg shadow-sm">
                    <h4 class="font-semibold mb-2 text-gray-800">Current Quality</h4>
                    <div class="flex justify-between items-center">
                        <span class="font-medium text-gray-700">PSNR (Quality):</span>
                        <span id="psnrValue" class="font-bold text-lg text-indigo-600">N/A</span>
                    </div>
                    <p class="text-sm text-gray-500 mt-2">Peak Signal-to-Noise Ratio. Higher is better. &infin;
                        indicates a perfect match.</p>
                </div>
            </div>
        </div>

        <div id="analysisContainer" class="mt-8 hidden">
            <h3 class="text-xl font-semibold mb-2">Analysis</h3>
            <div class="mb-6 border-b border-gray-200 pb-6">
                <button id="runFullAnalysisBtn"
                    class="bg-teal-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed"
                    disabled>Run Full Analysis</button>
                <p class="text-sm text-gray-500 mt-2">Click to calculate the image quality (PSNR) for every color count
                    from 2 up to the current slider value. Results will appear in a table below.</p>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <!-- PSNR (Quality) widget was here, now moved above -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="font-semibold text-gray-800">Generated Palette</h4>
                        <button id="exportPaletteBtn"
                            class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed"
                            disabled>Export</button>
                    </div>
                    <div id="paletteContainer"
                        class="grid grid-cols-8 sm:grid-cols-12 md:grid-cols-16 gap-2 bg-gray-50 p-4 rounded-lg">
                    </div>
                </div>
            </div>
        </div>

        <div id="fullAnalysisResults" class="mt-8 hidden">
            <h3 class="text-xl font-semibold mb-4">Full Analysis Results</h3>
            <div id="analysisTableContainer" class="w-full bg-gray-50 p-4 rounded-lg border">
                <table class="w-full text-left table-auto">
                    <thead>
                        <tr class="border-b-2 border-gray-200">
                            <th class="px-4 py-2">Color Count</th>
                            <th class="px-4 py-2">PSNR (dB)</th>
                            <th class="px-4 py-2">Delta from Previous</th>
                        </tr>
                    </thead>
                    <tbody id="analysisTableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="customColorPicker" class="hidden bg-white shadow-xl p-4 rounded-lg z-10 border border-gray-200"
        style="min-width: 250px;">
        <div class="flex mb-4 border-b">
            <button id="rgbTabBtn"
                class="px-3 py-2 text-sm font-medium text-indigo-700 border-b-2 border-indigo-500 focus:outline-none">RGB</button>
            <button id="hslTabBtn"
                class="px-3 py-2 text-sm font-medium text-gray-500 hover:text-gray-700 border-b-2 border-transparent focus:outline-none">HSL</button>
        </div>

        <div id="rgbPanel">
            <label for="nativeColorPickerInCustom" class="block text-xs font-medium text-gray-700 mb-2">Select RGB
                Color:</label>
            <input type="color" id="nativeColorPickerInCustom" value="#000000">
        </div>

        <div id="hslPanel" class="hidden">
            <div class="mb-2">
                <label for="hslH" class="block text-xs font-medium text-gray-700">Hue:</label>
                <input type="range" id="hslH" min="0" max="360" value="0"
                    class="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    style="background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red);">
                <span id="hslHValue" class="text-xs text-gray-600">0</span>
            </div>
            <div class="mb-2">
                <label for="hslS" class="block text-xs font-medium text-gray-700">Saturation:</label>
                <input type="range" id="hslS" min="0" max="100" value="0"
                    class="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    style="background: linear-gradient(to right, gray, #ff0000);">
                <span id="hslSValue" class="text-xs text-gray-600">0</span>
            </div>
            <div class="mb-2">
                <label for="hslL" class="block text-xs font-medium text-gray-700">Lightness:</label>
                <input type="range" id="hslL" min="0" max="100" value="0"
                    class="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    style="background: linear-gradient(to right, black, gray, white);">
                <span id="hslLValue" class="text-xs text-gray-600">0</span>
            </div>
            <div id="hslCurrentColorDisplay" class="w-full h-8 mt-4 rounded-lg border border-gray-200"></div>
        </div>

        <div class="flex justify-between gap-2 mt-4">
            <button id="confirmColorBtn"
                class="flex-1 bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105">Confirm</button>
            <button id="cancelColorBtn"
                class="flex-1 bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-transform transform hover:scale-105">Cancel</button>
        </div>
    </div>


    <script>
        // --- DOM Element References ---
        const imageUpload = document.getElementById('imageUpload');
        const colorSlider = document.getElementById('colorSlider');
        const sliderValueEl = document.getElementById('sliderValue');
        const originalCanvas = document.getElementById('originalCanvas');
        const quantizedCanvas = document.getElementById('quantizedCanvas');
        const statusEl = document.getElementById('status');
        const resultContainer = document.getElementById('resultContainer');
        const fileNameEl = document.getElementById('fileName');
        const analysisContainer = document.getElementById('analysisContainer');
        const psnrValueEl = document.getElementById('psnrValue');
        const paletteContainer = document.getElementById('paletteContainer');
        const exportPaletteBtn = document.getElementById('exportPaletteBtn');
        const runFullAnalysisBtn = document.getElementById('runFullAnalysisBtn');
        const fullAnalysisResults = document.getElementById('fullAnalysisResults');
        const analysisTableBody = document.getElementById('analysisTableBody');
        const originalImageSizeEl = document.getElementById('originalImageSize');
        const quantizedImageSizeEl = document.getElementById('quantizedImageSize');
        const appContainer = document.getElementById('appContainer'); // For drag/drop styling
        const algorithmSelect = document.getElementById('algorithmSelect'); // New: Algorithm dropdown

        const originalCtx = originalCanvas.getContext('2d');
        const quantizedCtx = quantizedCanvas.getContext('2d');
        let originalImageData = null;
        let currentPalette = [];
        let debounceTimer;
        let currentImageFile = null; // Store the current image file for size display

        // --- State variables for color editing ---
        let currentQuantizedImageData = null;
        let originalColorForEditing = null;
        let previewColor = null;
        let currentEditedSwatch = null;

        // --- Custom Color Picker DOM Elements ---
        const customColorPicker = document.getElementById('customColorPicker');
        const rgbTabBtn = document.getElementById('rgbTabBtn');
        const hslTabBtn = document.getElementById('hslTabBtn');
        const rgbPanel = document.getElementById('rgbPanel');
        const hslPanel = document.getElementById('hslPanel');
        const confirmColorBtn = document.getElementById('confirmColorBtn');
        const cancelColorBtn = document.getElementById('cancelColorBtn');
        const nativeColorPickerInCustom = document.getElementById('nativeColorPickerInCustom');
        const hslH = document.getElementById('hslH');
        const hslS = document.getElementById('hslS');
        const hslL = document.getElementById('hslL');
        const hslHValue = document.getElementById('hslHValue');
        const hslSValue = document.getElementById('hslSValue');
        const hslLValue = document.getElementById('hslLValue');
        const hslCurrentColorDisplay = document.getElementById('hslCurrentColorDisplay');

        // --- Event Listeners ---
        imageUpload.addEventListener('change', (e) => handleImageFile(e.target.files[0]));
        colorSlider.addEventListener('input', handleSliderChange);
        exportPaletteBtn.addEventListener('click', handleExportPalette);
        runFullAnalysisBtn.addEventListener('click', runFullAnalysis);
        rgbTabBtn.addEventListener('click', () => switchColorPickerTab('rgb'));
        hslTabBtn.addEventListener('click', () => switchColorPickerTab('hsl'));
        nativeColorPickerInCustom.addEventListener('input', handleNativeColorPickerInput);
        hslH.addEventListener('input', updateHslSlidersAndImage);
        hslS.addEventListener('input', updateHslSlidersAndImage);
        hslL.addEventListener('input', updateHslSlidersAndImage);
        confirmColorBtn.addEventListener('click', finalizeColorChange);
        cancelColorBtn.addEventListener('click', cancelColorChange);
        algorithmSelect.addEventListener('change', startQuantization); // New: Re-quantize when algorithm changes

        // Drag and Drop / Paste Listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Prevent default drag behaviors
            document.body.addEventListener('dragover', preventDefaults, false);
            document.body.addEventListener('dragleave', preventDefaults, false);
            document.body.addEventListener('drop', preventDefaults, false);

            // Add visual feedback for drag over
            document.body.addEventListener('dragenter', () => appContainer.classList.add('drag-over'), false);
            document.body.addEventListener('dragleave', () => appContainer.classList.remove('drag-over'), false);
            document.body.addEventListener('drop', () => appContainer.classList.remove('drag-over'), false);

            document.body.addEventListener('drop', handleDrop, false);
            document.body.addEventListener('paste', handlePaste, false);
        });

        const debouncedQuantize = debounce(startQuantization, 250);

        /**
         * Prevents default event behavior (e.g., opening dropped files).
         * @param {Event} e - The event object.
         */
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        /**
         * Handles image files from various sources (upload, drag/drop, paste).
         * @param {File} file - The image file to process.
         */
        function handleImageFile(file) {
            if (!file || file.type !== 'image/png') {
                updateStatus('Please select or drop/paste a PNG image file.', true);
                fileNameEl.textContent = 'Choose a PNG file...';
                originalImageSizeEl.textContent = '';
                quantizedImageSizeEl.textContent = '';
                return;
            }

            currentImageFile = file; // Store the file
            fileNameEl.textContent = file.name.length > 20 ? `${file.name.substring(0, 17)}...` : file.name;
            originalImageSizeEl.textContent = `(${formatBytes(file.size)})`;


            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalCanvas.width = img.width;
                    originalCanvas.height = img.height;
                    quantizedCanvas.width = img.width;
                    quantizedCanvas.height = img.height;

                    // Disable image smoothing for crisp pixel art
                    originalCtx.imageSmoothingEnabled = false;
                    quantizedCtx.imageSmoothingEnabled = false;
                    originalCtx.mozImageSmoothingEnabled = false; // For Firefox
                    quantizedCtx.mozImageSmoothingEnabled = false; // For Firefox
                    originalCtx.webkitImageSmoothingEnabled = false; // For Chrome/Safari
                    quantizedCtx.webkitImageSmoothingEnabled = false; // For Chrome/Safari
                    originalCtx.msImageSmoothingEnabled = false; // For Internet Explorer/Edge
                    quantizedCtx.msImageSmoothingEnabled = false; // For Internet Explorer/Edge

                    originalCtx.drawImage(img, 0, 0);
                    originalImageData = originalCtx.getImageData(0, 0, img.width, img.height);
                    resultContainer.classList.remove('hidden');
                    analysisContainer.classList.remove('hidden');
                    fullAnalysisResults.classList.add('hidden'); // Hide full analysis table on new upload
                    colorSlider.disabled = false;
                    exportPaletteBtn.disabled = false;
                    runFullAnalysisBtn.disabled = false;
                    algorithmSelect.disabled = false; // Enable algorithm selection
                    updateStatus('Image loaded. Move slider to change colors.');
                    startQuantization();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        /**
         * Handles the drop event for drag and drop.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDrop(e) {
            preventDefaults(e);
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                handleImageFile(files[0]); // Process only the first dropped file
            } else {
                updateStatus('No file dropped or invalid file type.', true);
            }
        }

        /**
         * Handles the paste event for pasting from clipboard.
         * @param {ClipboardEvent} e - The clipboard event object.
         */
        function handlePaste(e) {
            preventDefaults(e);
            const items = e.clipboardData.items;

            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const file = items[i].getAsFile();
                    if (file) {
                        handleImageFile(file);
                        return; // Process only the first image found
                    }
                }
            }
            updateStatus('No image found in clipboard.', true);
        }

        /**
         * Formats a byte size into a human-readable string (e.g., KB, MB).
         * @param {number} bytes - The size in bytes.
         * @param {number} decimals - Number of decimal places.
         * @returns {string} Formatted size string.
         */
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        /**
         * Debounces a function call to prevent it from being called too frequently.
         * @param {Function} func - The function to debounce.
         * @param {number} delay - The delay in milliseconds.
         * @returns {Function} The debounced function.
         */
        function debounce(func, delay) {
            return function (...args) {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => func.apply(this, args), delay);
            };
        }

        /**
         * Handles the change event of the color slider.
         * Updates the slider value display and triggers debounced quantization.
         */
        function handleSliderChange() {
            sliderValueEl.textContent = colorSlider.value;
            if (originalImageData) {
                updateStatus(`Waiting to process for ${colorSlider.value} colors...`);
                debouncedQuantize();
            }
        }

        /**
         * Updates the status message displayed to the user.
         * @param {string} message - The message to display.
         * @param {boolean} [isError=false] - Whether the message is an error.
         */
        function updateStatus(message, isError = false) {
            statusEl.textContent = message;
            statusEl.style.color = isError ? '#dc2626' : '#4b5563';
        }

        /**
         * Initiates the image quantization process using the current slider value and selected algorithm.
         */
        function startQuantization() {
            if (!originalImageData) return;
            const k = parseInt(colorSlider.value, 10);
            const algorithm = algorithmSelect.value;
            let algorithmDescription = algorithmSelect.options[algorithmSelect.selectedIndex].textContent;
            updateStatus(`Processing for ${k} colors using ${algorithmDescription}...`);
            setTimeout(() => {
                try {
                    let quantizedResult;
                    if (algorithm === 'median-cut') {
                        quantizedResult = quantizeMedianCut(originalImageData, k);
                    } else if (algorithm === 'k-means') {
                        quantizedResult = quantizeKMeans(originalImageData, k);
                    } else if (algorithm === 'neuquant') {
                        quantizedResult = quantizeNeuQuant(originalImageData, k);
                    } else if (algorithm === 'octree') {
                        quantizedResult = quantizeOctree(originalImageData, k);
                    }
                    else {
                        throw new Error('Unknown quantization algorithm selected.');
                    }

                    currentQuantizedImageData = new ImageData(
                        new Uint8ClampedArray(quantizedResult.quantizedData.data),
                        quantizedResult.quantizedData.width,
                        quantizedResult.quantizedData.height
                    );
                    quantizedCtx.putImageData(currentQuantizedImageData, 0, 0);

                    // Calculate and display PSNR
                    const psnr = calculatePSNR(originalImageData, currentQuantizedImageData);
                    psnrValueEl.innerHTML = isFinite(psnr) ? `${psnr.toFixed(2)} dB` : `&infin;`;

                    // Calculate and display quantized image size
                    const quantizedDataUrl = quantizedCanvas.toDataURL('image/png');
                    const base64Data = quantizedDataUrl.split(',')[1];
                    const estimatedSize = (base64Data.length * 0.75);
                    quantizedImageSizeEl.textContent = `(${formatBytes(estimatedSize)})`;

                    // Store and display the generated palette
                    currentPalette = quantizedResult.palette;
                    displayPalette(currentPalette);
                    updateStatus(`Image quantized to ${k} colors using ${algorithmDescription}.`);
                } catch (error) {
                    console.error("Quantization error:", error);
                    updateStatus('An error occurred during quantization: ' + error.message, true);
                }
            }, 10); // Small delay to allow UI update
        }

        /**
         * Quantizes an image using the Median Cut algorithm with CIELAB ΔE76 distance accelerated by a k-d tree.
         * Performs clustering in Lab space for both splitting and nearest‐neighbor mapping.
         * @param {ImageData} imageData - The original image data.
         * @param {number} k - The desired number of colors.
         * @returns {{quantizedData: ImageData, palette: number[][]}} The quantized image data and the generated palette.
         */
        function quantizeMedianCut(imageData, k) {
            const pixels = getPixelsMedianCut(imageData); // Now returns {rgb, lab} objects
            if (pixels.length === 0) {
                return {
                    quantizedData: new ImageData(imageData.width, imageData.height),
                    palette: []
                };
            }

            const initialBucket = [pixels];
            const buckets = splitBucketsMedianCut(initialBucket, k);
            const palette = buckets.filter(b => b.length > 0).map(getAverageColorMedianCut); // getAverageColor now returns RGB
            const quantizedData = mapPixelsToPaletteMedianCut(imageData, palette);
            return { quantizedData, palette };
        }

        /**
         * Quantizes an image using the K-Means Clustering algorithm.
         * @param {ImageData} imageData - The original image data.
         * @param {number} k - The desired number of colors.
         * @param {number} maxIterations - Maximum number of iterations for K-Means.
         * @returns {{quantizedData: ImageData, palette: number[][]}} The quantized image data and the generated palette.
         */
        function quantizeKMeans(imageData, k, maxIterations = 20) {
            const pixels = getPixelsRGB(imageData); // Use generic RGB pixel extractor

            if (pixels.length === 0) return { quantizedData: new ImageData(imageData.width, imageData.height), palette: [] };
            if (k > pixels.length) k = pixels.length; // Cannot have more centroids than pixels

            // 1. Initialize centroids randomly from the image's pixels
            let centroids = [];
            const pixelIndices = Array.from({ length: pixels.length }, (_, i) => i);
            for (let i = 0; i < k; i++) {
                const randomIndex = pixelIndices.splice(Math.floor(Math.random() * pixelIndices.length), 1)[0];
                centroids.push([...pixels[randomIndex]]); // Use spread to copy array, not reference
            }

            let assignments = new Uint32Array(pixels.length); // Store index of centroid for each pixel
            let changed = true;
            let iteration = 0;

            while (changed && iteration < maxIterations) {
                changed = false;
                iteration++;

                // 2. Assignment Step: Assign each pixel to the closest centroid
                for (let i = 0; i < pixels.length; i++) {
                    const pixel = pixels[i];
                    let minDistanceSquared = Infinity;
                    let closestCentroidIndex = -1;

                    for (let j = 0; j < k; j++) {
                        const centroid = centroids[j];
                        const distanceSquared =
                            (pixel[0] - centroid[0]) ** 2 +
                            (pixel[1] - centroid[1]) ** 2 +
                            (pixel[2] - centroid[2]) ** 2;

                        if (distanceSquared < minDistanceSquared) {
                            minDistanceSquared = distanceSquared;
                            closestCentroidIndex = j;
                        }
                    }

                    if (assignments[i] !== closestCentroidIndex) {
                        assignments[i] = closestCentroidIndex;
                        changed = true;
                    }
                }

                // 3. Update Step: Recalculate centroids
                const newCentroids = Array.from({ length: k }, () => [0, 0, 0, 0]); // [R, G, B, count]
                for (let i = 0; i < pixels.length; i++) {
                    const pixel = pixels[i];
                    const centroidIndex = assignments[i];
                    if (centroidIndex !== -1) { // Ensure pixel was assigned
                        newCentroids[centroidIndex][0] += pixel[0];
                        newCentroids[centroidIndex][1] += pixel[1];
                        newCentroids[centroidIndex][2] += pixel[2];
                        newCentroids[centroidIndex][3]++; // Increment count
                    }
                }

                // Update centroids, only if there are pixels assigned to them
                for (let i = 0; i < k; i++) {
                    if (newCentroids[i][3] > 0) {
                        centroids[i] = [
                            Math.round(newCentroids[i][0] / newCentroids[i][3]),
                            Math.round(newCentroids[i][1] / newCentroids[i][3]),
                            Math.round(newCentroids[i][2] / newCentroids[i][3])
                        ];
                    } else {
                        // If a centroid has no assigned pixels, re-initialize it randomly
                        // This helps prevent "dead" centroids
                        const randomIndex = Math.floor(Math.random() * pixels.length);
                        centroids[i] = [...pixels[randomIndex]];
                        changed = true; // Mark as changed to continue iterations
                    }
                }
            }

            // The final palette is the set of centroids
            const palette = centroids;

            // Map original pixels to the closest color in the final palette
            const quantizedData = mapPixelsToPaletteKMeans(imageData, palette); // Use a dedicated mapping function for KMeans
            return { quantizedData, palette };
        }

        /**
         * Quantizes an image using a perceptually-weighted SOM (NeuQuant-like) algorithm.
         * Neighbourhood is based on RGB-distance, not palette index; learning-rate and
         * radius decay exponentially. Uses weighted RGB distance (0.30 R, 0.59 G, 0.11 B).
         * @param {ImageData} imageData
         * @param {number} k
         * @param {number} initialLearningRate
         * @param {number} initialRadius
         * @param {number} maxIterations
         * @returns {{quantizedData: ImageData, palette: number[][]}}
         */
        function quantizeNeuQuant(
            imageData,
            k,
            initialLearningRate = 0.2,
            initialRadius = 30,
            maxIterations = 30 * k
        ) {
            const pixels = getPixelsRGB(imageData); // Use generic RGB pixel extractor

            if (pixels.length === 0)
                return { quantizedData: new ImageData(imageData.width, imageData.height), palette: [] };

            const colorMap = Array.from({ length: k }, () => [
                Math.floor(Math.random() * 256),
                Math.floor(Math.random() * 256),
                Math.floor(Math.random() * 256)
            ]);

            const numIters = Math.min(pixels.length, maxIterations);
            const tau = numIters; // decay constant

            for (let i = 0; i < numIters; i++) {
                const currentPixel = pixels[Math.floor(Math.random() * pixels.length)];

                // exponential decay
                const learningRate = initialLearningRate * Math.exp(-i / tau);
                const radius = initialRadius * Math.exp(-i / tau);

                // find BMU
                let bmuIndex = 0;
                let minDist = Infinity;
                for (let j = 0; j < k; j++) {
                    const dist = weightedRgbDistance(currentPixel, colorMap[j]);
                    if (dist < minDist) {
                        minDist = dist;
                        bmuIndex = j;
                    }
                }

                const bmuColor = colorMap[bmuIndex];

                // update BMU and neighbours (based on RGB distance)
                for (let j = 0; j < k; j++) {
                    const neighbourDist = weightedRgbDistance(colorMap[j], bmuColor);
                    if (neighbourDist <= radius) {
                        const influence = Math.exp(-(neighbourDist * neighbourDist) / (2 * radius * radius));
                        const alpha = learningRate * influence;

                        colorMap[j][0] = clamp(colorMap[j][0] + alpha * (currentPixel[0] - colorMap[j][0]));
                        colorMap[j][1] = clamp(colorMap[j][1] + alpha * (currentPixel[1] - colorMap[j][1]));
                        colorMap[j][2] = clamp(colorMap[j][2] + alpha * (currentPixel[2] - colorMap[j][2]));
                    }
                }
            }

            const palette = colorMap;
            const quantizedData = mapPixelsToPaletteKMeans(imageData, palette); // Using KMeans mapper for consistency
            return { quantizedData, palette };
        }

        // Min-heap for reducible nodes
        class MinHeap {
            constructor() {
                this.a = [];
            }
            push(node) {
                this.a.push(node);
                this.#up(this.a.length - 1);
            }
            pop() {
                if (this.a.length === 0) return null;
                const top = this.a[0];
                const last = this.a.pop();
                if (this.a.length) {
                    this.a[0] = last;
                    this.#down(0);
                }
                return top;
            }
            isEmpty() {
                return this.a.length === 0;
            }
            #up(i) {
                while (i > 0) {
                    const p = (i - 1) >> 1;
                    if (this.a[i].pixelCount >= this.a[p].pixelCount) break;
                    [this.a[i], this.a[p]] = [this.a[p], this.a[i]];
                    i = p;
                }
            }
            #down(i) {
                while (true) {
                    const l = (i << 1) + 1;
                    const r = l + 1;
                    let smallest = i;
                    if (l < this.a.length && this.a[l].pixelCount < this.a[smallest].pixelCount) smallest = l;
                    if (r < this.a.length && this.a[r].pixelCount < this.a[smallest].pixelCount) smallest = r;
                    if (smallest === i) break;
                    [this.a[i], this.a[smallest]] = [this.a[smallest], this.a[i]];
                    i = smallest;
                }
            }
        }

        /**
         * OctreeNode class for Octree quantization.
         */
        class OctreeNode {
            constructor(level, parent) {
                this.children = new Array(8).fill(null);
                this.isLeaf = true;
                this.pixelCount = 0;
                this.redSum = 0;
                this.greenSum = 0;
                this.blueSum = 0;
                this.paletteIndex = -1;
                this.level = level;
                this.parent = parent;
            }

            /**
             * Corrected method to add a pixel to the octree. It now handles
             * splitting leaf nodes into internal nodes correctly.
             */
            addPixel(pixel, level, reducibleHeaps) {
                // If this node is not a leaf, pass the pixel down to the correct child.
                if (!this.isLeaf) {
                    const childIndex = getOctreeChildIndex(pixel, level);
                    if (!this.children[childIndex]) {
                        this.children[childIndex] = new OctreeNode(level + 1, this);
                    }
                    this.children[childIndex].addPixel(pixel, level + 1, reducibleHeaps);
                    return;
                }

                // If this is a leaf node, it needs to be split, unless at max depth.
                // Level 7 is the last level where we can create children.
                if (level === 7) {
                    this.pixelCount++;
                    this.redSum += pixel[0];
                    this.greenSum += pixel[1];
                    this.blueSum += pixel[2];
                    return;
                }

                // Redistribute the pixel(s) this leaf already holds.
                if (this.pixelCount > 0) {
                    const oldColor = [
                        this.redSum / this.pixelCount,
                        this.greenSum / this.pixelCount,
                        this.blueSum / this.pixelCount
                    ];
                    const oldIndex = getOctreeChildIndex(oldColor, level);

                    this.children[oldIndex] = new OctreeNode(level + 1, this);
                    this.children[oldIndex].pixelCount = this.pixelCount;
                    this.children[oldIndex].redSum = this.redSum;
                    this.children[oldIndex].greenSum = this.greenSum;
                    this.children[oldIndex].blueSum = this.blueSum;
                }
                
                // This node is now an internal node.
                this.isLeaf = false;
                this.pixelCount = 0;
                this.redSum = 0;
                this.greenSum = 0;
                this.blueSum = 0;
                reducibleHeaps[this.level].push(this);

                // Add the new pixel to its correct child.
                const newIndex = getOctreeChildIndex(pixel, level);
                if (!this.children[newIndex]) {
                    this.children[newIndex] = new OctreeNode(level + 1, this);
                }
                this.children[newIndex].addPixel(pixel, level + 1, reducibleHeaps);
            }

            mergeChildren() {
                if (this.isLeaf) return;
                for (let i = 0; i < 8; i++) {
                    const child = this.children[i];
                    if (child) {
                        this.redSum += child.redSum;
                        this.greenSum += child.greenSum;
                        this.blueSum += child.blueSum;
                        this.pixelCount += child.pixelCount;
                        this.children[i] = null;
                    }
                }
                this.isLeaf = true;
            }

            getLeaves(leaves) {
                if (this.isLeaf) {
                    if (this.pixelCount) leaves.push(this);
                } else {
                    for (let i = 0; i < 8; i++) {
                        if (this.children[i]) this.children[i].getLeaves(leaves);
                    }
                }
            }

            getAverageColor() {
                if (this.pixelCount === 0) return [0, 0, 0];
                return [
                    Math.round(this.redSum / this.pixelCount),
                    Math.round(this.greenSum / this.pixelCount),
                    Math.round(this.blueSum / this.pixelCount)
                ];
            }
        }

        function getOctreeChildIndex(pixel, level) {
            let index = 0;
            const bit = 7 - level;
            if ((pixel[0] >> bit) & 1) index |= 4;
            if ((pixel[1] >> bit) & 1) index |= 2;
            if ((pixel[2] >> bit) & 1) index |= 1;
            return index;
        }

        /**
         * Quantizes an image using the Octree algorithm with heap-based reduction.
         * @param {ImageData} imageData
         * @param {number} k
         * @returns {{quantizedData: ImageData, palette: number[][]}}
         */
        function quantizeOctree(imageData, k) {
            const pixels = getPixelsRGB(imageData); // Use generic RGB pixel extractor

            if (!pixels.length) return { quantizedData: new ImageData(imageData.width, imageData.height), palette: [] };

            const root = new OctreeNode(0, null);
            const reducibleHeaps = Array.from({ length: 8 }, () => new MinHeap());

            for (const pixel of pixels) {
                root.addPixel(pixel, 0, reducibleHeaps);
            }

            const leaves = [];
            root.getLeaves(leaves);
            let leafCount = leaves.length;

            if (leafCount > k) {
                let level = 7;
                while (leafCount > k && level >= 0) {
                    if (reducibleHeaps[level].isEmpty()) {
                        level--;
                        continue;
                    }
                    
                    const node = reducibleHeaps[level].pop();
                    if (!node) continue;

                    // Correctly count all leaves that will be removed by the merge.
                    const leavesToRemove = [];
                    node.getLeaves(leavesToRemove);
                    const removedLeafCount = leavesToRemove.length;

                    node.mergeChildren();
                    
                    // Update the leaf count accurately.
                    leafCount = leafCount - removedLeafCount + 1;
                }
            }

            const finalLeaves = [];
            root.getLeaves(finalLeaves);
            const palette = finalLeaves.map(l => l.getAverageColor());
            
            const quantizedData = mapPixelsToPaletteKMeans(imageData, palette); // Using KMeans mapper for consistency
            return { quantizedData, palette };
        }


        /**
         * Calculates the perceptually weighted RGB distance between two colors.
         * @param {number[]} a - First color [R, G, B].
         * @param {number[]} b - Second color [R, G, B].
         * @returns {number} The weighted Euclidean distance.
         */
        function weightedRgbDistance(a, b) {
            const dR = a[0] - b[0];
            const dG = a[1] - b[1];
            const dB = a[2] - b[2];
            return Math.sqrt(0.30 * dR * dR + 0.59 * dG * dG + 0.11 * dB * dB);
        }

        /**
         * Clamps a value to the 0-255 range and rounds it.
         * @param {number} v - The value to clamp.
         * @returns {number} The clamped and rounded value.
         */
        function clamp(v) {
            return Math.min(255, Math.max(0, Math.round(v)));
        }


        /**
         * Extracts non-transparent pixels and converts them to Lab.
         * This version is specifically for Median Cut.
         * @param {ImageData} imageData
         * @returns {Array<{rgb:number[],lab:number[]}>}
         */
        function getPixelsMedianCut(imageData) {
            const pixels = [];
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const alpha = data[i + 3];
                if (alpha > 128) {
                    const rgb = [data[i], data[i + 1], data[i + 2]];
                    const lab = rgbToLab(rgb);
                    pixels.push({ rgb, lab });
                }
            }
            return pixels;
        }

        /**
         * Extracts non-transparent pixel RGB values from ImageData.
         * This is a generic utility function for algorithms that work in RGB space.
         * @param {ImageData} imageData - The image data.
         * @returns {number[][]} An array of [R, G, B] pixel arrays.
         */
        function getPixelsRGB(imageData) {
            const pixels = [];
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                // Only consider pixels with significant alpha (not fully transparent)
                if (data[i + 3] > 128) {
                    pixels.push([data[i], data[i + 1], data[i + 2]]);
                }
            }
            return pixels;
        }

        /**
         * Splits buckets based on greatest Lab‐channel range.
         * This version is specifically for Median Cut.
         * @param {Array<Array<{rgb:number[],lab:number[]}>>} buckets
         * @param {number} k
         */
        function splitBucketsMedianCut(buckets, k) {
            while (buckets.length < k) {
                let bucketToSplit = -1;
                let maxRange = -1;
                let channelIndexToSplit = -1;

                for (let i = 0; i < buckets.length; i++) {
                    const bucket = buckets[i];
                    if (bucket.length > 1) {
                        const { range, channelIndex } = findGreatestRangeChannelMedianCut(bucket);
                        if (range > maxRange) {
                            maxRange = range;
                            bucketToSplit = i;
                            channelIndexToSplit = channelIndex;
                        }
                    }
                }

                if (bucketToSplit === -1) break;

                const bucket = buckets[bucketToSplit];
                bucket.sort((a, b) => a.lab[channelIndexToSplit] - b.lab[channelIndexToSplit]);
                const medianIndex = Math.floor(bucket.length / 2);
                buckets.splice(
                    bucketToSplit,
                    1,
                    bucket.slice(0, medianIndex),
                    bucket.slice(medianIndex)
                );
            }
            return buckets;
        }

        /**
         * Finds the Lab channel with the greatest range in a bucket.
         * This version is specifically for Median Cut.
         * @param {Array<{rgb:number[],lab:number[]}>} bucket
         */
        function findGreatestRangeChannelMedianCut(bucket) {
            let min0 = Infinity, max0 = -Infinity;
            let min1 = Infinity, max1 = -Infinity;
            let min2 = Infinity, max2 = -Infinity;

            for (const p of bucket) {
                const [L, a, b] = p.lab;
                if (L < min0) min0 = L; if (L > max0) max0 = L;
                if (a < min1) min1 = a; if (a > max1) max1 = a;
                if (b < min2) min2 = b; if (b > max2) max2 = b;
            }

            const range0 = max0 - min0;
            const range1 = max1 - min1;
            const range2 = max2 - min2;

            if (range0 >= range1 && range0 >= range2) return { channelIndex: 0, range: range0 };
            if (range1 >= range0 && range1 >= range2) return { channelIndex: 1, range: range1 };
            return { channelIndex: 2, range: range2 };
        }

        /**
         * Averages Lab colors in a bucket and converts back to RGB.
         * This version is specifically for Median Cut.
         * @param {Array<{rgb:number[],lab:number[]}>} bucket
         */
        function getAverageColorMedianCut(bucket) {
            let sumL = 0, sumA = 0, sumB = 0;
            for (const p of bucket) {
                sumL += p.lab[0];
                sumA += p.lab[1];
                sumB += p.lab[2];
            }
            const avgLab = [
                sumL / bucket.length,
                sumA / bucket.length,
                sumB / bucket.length
            ];
            return labToRgb(avgLab);
        }

        /**
         * Maps each pixel to the nearest palette color using a k-d tree in Lab space.
         * This version is specifically for Median Cut.
         * @param {ImageData} original
         * @param {number[][]} palette
         */
        function mapPixelsToPaletteMedianCut(original, palette) {
            const newImageData = new ImageData(original.width, original.height);
            if (palette.length === 0) return newImageData;

            const palettePoints = palette.map(rgb => ({ rgb, lab: rgbToLab(rgb) }));
            const kdTree = buildKdTree(palettePoints);
            const memo = new Map();

            const originalData = original.data;
            const newData = newImageData.data;

            for (let i = 0; i < originalData.length; i += 4) {
                const alpha = originalData[i + 3];
                if (alpha < 128) {
                    newData[i]     = originalData[i];
                    newData[i + 1] = originalData[i + 1];
                    newData[i + 2] = originalData[i + 2];
                    newData[i + 3] = alpha;
                    continue;
                }

                const r = originalData[i],
                      g = originalData[i + 1],
                      b = originalData[i + 2];
                const key = (r << 16) | (g << 8) | b;

                let newColor = memo.get(key);
                if (!newColor) {
                    const lab = rgbToLab([r, g, b]);
                    newColor = kdNearest(kdTree, lab).point.rgb;
                    memo.set(key, newColor);
                }

                newData[i]     = newColor[0];
                newData[i + 1] = newColor[1];
                newData[i + 2] = newColor[2];
                newData[i + 3] = alpha;
            }

            return newImageData;
        }

        // Color‐space conversions and KD‐tree utilities

        function rgbToXyz([r, g, b]) {
            let [sr, sg, sb] = [r, g, b].map(v => {
                v /= 255;
                return v > 0.04045
                    ? Math.pow((v + 0.055) / 1.055, 2.4)
                    : v / 12.92;
            });
            return [
                sr * 0.4124564 + sg * 0.3575761 + sb * 0.1804375,
                sr * 0.2126729 + sg * 0.7151522 + sb * 0.0721750,
                sr * 0.0193339 + sg * 0.1191920 + sb * 0.9503041
            ];
        }

        function xyzToLab([x, y, z]) {
            const [Xn, Yn, Zn] = [0.95047, 1.00000, 1.08883]; // D65 Illuminant
            const f = t => t > 0.008856 ? Math.cbrt(t) : (7.787 * t + 16/116);
            const fx = f(x / Xn), fy = f(y / Yn), fz = f(z / Zn);
            return [
                116 * fy - 16,
                500 * (fx - fy),
                200 * (fy - fz)
            ];
        }

        function rgbToLab(rgb) {
            return xyzToLab(rgbToXyz(rgb));
        }

        function labToXyz([L, a, b]) {
            const [Xn, Yn, Zn] = [0.95047, 1.00000, 1.08883];
            const fy = (L + 16) / 116;
            const fx = a / 500 + fy;
            const fz = fy - b / 200;
            const cube = t => t * t * t;
            const inv = t => cube(t) > 0.008856 ? cube(t) : (t - 16/116) / 7.787;
            return [
                Xn * inv(fx),
                Yn * inv(fy),
                Zn * inv(fz)
            ];
        }

        function xyzToRgb([x, y, z]) {
            let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
            let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
            let b = x * 0.0557 + y * -0.2040 + z * 1.0570;
            const gamma = v => v > 0.0031308
                ? 1.055 * Math.pow(v, 1/2.4) - 0.055
                : 12.92 * v;
            r = Math.min(Math.max(0, gamma(r)), 1);
            g = Math.min(Math.max(0, gamma(g)), 1);
            b = Math.min(Math.max(0, gamma(b)), 1);
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function labToRgb(lab) {
            return xyzToRgb(labToXyz(lab));
        }

        function distanceSquaredLab(a, b) {
            const d0 = a[0] - b[0],
                d1 = a[1] - b[1],
                d2 = a[2] - b[2];
            return d0 * d0 + d1 * d1 + d2 * d2;
        }

        function buildKdTree(points, depth = 0) {
            if (points.length === 0) return null;
            const axis = depth % 3; // Cycle through L, a, b axes
            points.sort((a, b) => a.lab[axis] - b.lab[axis]);
            const median = Math.floor(points.length / 2);
            return {
                point: points[median],
                axis,
                left: buildKdTree(points.slice(0, median), depth + 1),
                right: buildKdTree(points.slice(median + 1), depth + 1)
            };
        }

        function kdNearest(node, targetLab, best = { point: null, dist: Infinity }) {
            if (!node) return best;

            // Check current node
            const d = distanceSquaredLab(targetLab, node.point.lab);
            if (d < best.dist) {
                best = { point: node.point, dist: d };
            }

            const axis = node.axis;
            const diff = targetLab[axis] - node.point.lab[axis];

            // Decide which child to search first
            const nearer = diff < 0 ? node.left : node.right;
            const farther = diff < 0 ? node.right : node.left;

            // Search the nearer subtree
            best = kdNearest(nearer, targetLab, best);

            // Check if the farther subtree could contain a closer point
            if (diff * diff < best.dist) {
                best = kdNearest(farther, targetLab, best);
            }

            return best;
        }

        /**
         * Finds the closest color in a palette to a given color using Euclidean distance in RGB space.
         * This function is now specifically for K-Means and NeuQuant.
         * @param {number[]} color - The [R, G, B] color to match.
         * @param {number[][]} palette - The array of [R, G, B] colors in the palette.
         * @returns {number[]} The closest [R, G, B] color from the palette.
         */
        function findClosestColor(color, palette) {
            let minDistanceSquared = Infinity;
            let closestColor = palette[0]; // Initialize with the first color in the palette

            for (const paletteColor of palette) {
                // Calculate squared Euclidean distance
                const distanceSquared =
                    (color[0] - paletteColor[0]) ** 2 +
                    (color[1] - paletteColor[1]) ** 2 +
                    (color[2] - paletteColor[2]) ** 2;

                if (distanceSquared < minDistanceSquared) {
                    minDistanceSquared = distanceSquared;
                    closestColor = paletteColor;
                }
            }
            return closestColor;
        }

        /**
         * Maps each pixel in the original image to the closest color in the new palette.
         * This version is specifically for KMeans and NeuQuant, using RGB distance.
         * @param {ImageData} original - The original image data.
         * @param {number[][]} palette - The new color palette.
         * @returns {ImageData} The new image data with quantized colors.
         */
        function mapPixelsToPaletteKMeans(original, palette) {
            const newImageData = new ImageData(original.width, original.height);
            if (palette.length === 0) return newImageData; // Return empty if palette is empty

            const originalData = original.data;
            const newData = newImageData.data;
            const memo = {}; // Memoization to avoid recalculating closest color for identical original pixels

            for (let i = 0; i < originalData.length; i += 4) {
                const alpha = originalData[i + 3];
                // Preserve transparency for transparent pixels
                if (alpha < 128) {
                    newData[i] = originalData[i];
                    newData[i + 1] = originalData[i + 1];
                    newData[i + 2] = originalData[i + 2];
                    newData[i + 3] = alpha;
                    continue;
                }

                const r = originalData[i];
                const g = originalData[i + 1];
                const b = originalData[i + 2];
                const key = `${r}|${g}|${b}`; // Create a unique key for the original color

                let newColor = memo[key];
                if (!newColor) {
                    // If not memoized, find the closest color in the palette
                    newColor = findClosestColor([r, g, b], palette);
                    memo[key] = newColor; // Store for future use
                }

                newData[i] = newColor[0];
                newData[i + 1] = newColor[1];
                newData[i + 2] = newColor[2];
                newData[i + 3] = alpha; // Keep original alpha for non-transparent pixels
            }
            return newImageData;
        }

        /**
         * Calculates the Peak Signal-to-Noise Ratio (PSNR) between two ImageData objects.
         * @param {ImageData} original - The original image data.
         * @param {ImageData} quantized - The quantized image data.
         * @returns {number} The PSNR value in dB, or Infinity if images are identical.
         */
        function calculatePSNR(original, quantized) {
            const dataOriginal = original.data;
            const dataQuantized = quantized.data;
            let mse = 0; // Mean Squared Error
            let pixelCount = 0;

            for (let i = 0; i < dataOriginal.length; i += 4) {
                // Only consider non-transparent pixels for PSNR calculation
                if (dataOriginal[i + 3] > 128) {
                    mse += (dataOriginal[i] - dataQuantized[i]) ** 2;     // Red channel
                    mse += (dataOriginal[i + 1] - dataQuantized[i + 1]) ** 2; // Green channel
                    mse += (dataOriginal[i + 2] - dataQuantized[i + 2]) ** 2; // Blue channel
                    pixelCount++;
                }
            }

            if (mse === 0) {
                return Infinity; // Perfect match, no error
            }

            // Average MSE over all color channels and pixels
            mse = mse / (pixelCount * 3);
            const maxPixelValue = 255; // Max possible pixel value for 8-bit images
            return 20 * Math.log10(maxPixelValue) - 10 * Math.log10(mse);
        }

        /**
         * Displays the generated color palette as clickable swatches.
         * Each swatch allows editing its color.
         * @param {number[][]} palette - The array of [R, G, B] colors in the palette.
         */
        function displayPalette(palette) {
            paletteContainer.innerHTML = ''; // Clear previous palette
            palette.forEach((color) => {
                const [r, g, b] = color;
                const hex = rgbToHex(r, g, b);

                const swatch = document.createElement('div');
                swatch.className = 'palette-swatch';
                swatch.style.backgroundColor = hex;
                swatch.dataset.r = r; // Store RGB values as data attributes
                swatch.dataset.g = g;
                swatch.dataset.b = b;
                swatch.title = `Click to edit ${hex}`;
                swatch.innerHTML = `<span>${hex}</span>`;

                // Add event listener for editing a color in the palette
                swatch.addEventListener('click', (event) => {
                    event.preventDefault();
                    currentEditedSwatch = swatch; // Keep track of which swatch is being edited
                    originalColorForEditing = [parseInt(swatch.dataset.r), parseInt(swatch.dataset.g), parseInt(swatch.dataset.b)];
                    previewColor = [...originalColorForEditing]; // Start preview with original color

                    const currentHex = rgbToHex(...originalColorForEditing);
                    hslCurrentColorDisplay.style.backgroundColor = currentHex;
                    nativeColorPickerInCustom.value = currentHex;

                    customColorPicker.classList.remove('hidden'); // Show the custom color picker

                    // Position the color picker near the clicked swatch
                    const rect = swatch.getBoundingClientRect();
                    let pickerTop = rect.bottom + window.scrollY + 10;
                    let pickerLeft = rect.left + window.scrollX;

                    // Adjust position if it goes off-screen
                    if (pickerLeft + customColorPicker.offsetWidth > window.innerWidth) {
                        pickerLeft = window.innerWidth - customColorPicker.offsetWidth - 20;
                    }
                    if (pickerLeft < 0) pickerLeft = 20; // Ensure it's not off the left edge

                    if (pickerTop + customColorPicker.offsetHeight > window.innerHeight + window.scrollY) {
                        pickerTop = rect.top + window.scrollY - customColorPicker.offsetHeight - 10;
                        if (pickerTop < 0) pickerTop = 20; // Ensure it's not off the top edge
                    }

                    customColorPicker.style.top = `${pickerTop}px`;
                    customColorPicker.style.left = `${pickerLeft}px`;

                    switchColorPickerTab('rgb'); // Default to RGB tab
                });
                paletteContainer.appendChild(swatch);
            });
        }

        /**
         * Replaces an old color with a new color in the quantized image data and redraws it.
         * @param {ImageData} imageData - The quantized image data.
         * @param {number[]} oldColor - The [R, G, B] color to replace.
         * @param {number[]} newColor - The new [R, G, B] color.
         */
        function replaceColorInImageData(imageData, oldColor, newColor) {
            const data = imageData.data;
            const [oldR, oldG, oldB] = oldColor;
            const [newR, newG, newB] = newColor;

            for (let i = 0; i < data.length; i += 4) {
                // Check if the current pixel matches the old color
                if (data[i] === oldR && data[i + 1] === oldG && data[i + 2] === oldB) {
                    data[i] = newR;
                    data[i + 1] = newG;
                    data[i + 2] = newB;
                }
            }
            // Put the modified image data back onto the canvas
            quantizedCtx.putImageData(imageData, 0, 0);
        }

        /**
         * Switches between RGB and HSL tabs in the custom color picker.
         * @param {'rgb'|'hsl'} tabName - The name of the tab to switch to.
         */
        function switchColorPickerTab(tabName) {
            // Get the current color from the native color picker (which is always updated)
            const currentHex = nativeColorPickerInCustom.value;
            const [currentR, currentG, currentB] = hexToRgb(currentHex);

            if (tabName === 'rgb') {
                rgbPanel.classList.remove('hidden');
                hslPanel.classList.add('hidden');
                rgbTabBtn.classList.add('border-indigo-500', 'text-indigo-700');
                rgbTabBtn.classList.remove('border-transparent', 'text-gray-500');
                hslTabBtn.classList.remove('border-indigo-500', 'text-indigo-700');
                hslTabBtn.classList.add('border-transparent', 'text-gray-500');
            } else if (tabName === 'hsl') {
                hslPanel.classList.remove('hidden');
                rgbPanel.classList.add('hidden');
                hslTabBtn.classList.add('border-indigo-500', 'text-indigo-700');
                hslTabBtn.classList.remove('border-transparent', 'text-gray-500');
                rgbTabBtn.classList.remove('border-indigo-500', 'text-indigo-700');
                rgbTabBtn.classList.add('border-transparent', 'text-gray-500');

                // Convert current RGB to HSL and update HSL sliders
                const hsl = rgbToHsl(currentR, currentG, currentB);
                hslH.value = hsl[0];
                hslS.value = hsl[1];
                hslL.value = hsl[2];
                hslHValue.textContent = hsl[0];
                hslSValue.textContent = `${hsl[1]}%`;
                hslLValue.textContent = `${hsl[2]}%`;
                hslCurrentColorDisplay.style.backgroundColor = currentHex;
            }
        }

        /**
         * Applies a live preview of the new color on the quantized image.
         * @param {number[]} newColor - The new [R, G, B] color to preview.
         */
        function handleLivePreview(newColor) {
            if (!currentQuantizedImageData || !previewColor) return;

            // Create a temporary copy of the current quantized image data for preview
            const tempImageData = new ImageData(
                new Uint8ClampedArray(currentQuantizedImageData.data),
                currentQuantizedImageData.width,
                currentQuantizedImageData.height
            );

            // Replace the old preview color with the new one in the temporary data
            replaceColorInImageData(tempImageData, previewColor, newColor);

            // Update the quantized canvas with the temporary data
            quantizedCtx.putImageData(tempImageData, 0, 0);

            // Update the previewColor to the new color for the next live preview step
            previewColor = newColor;
            updateStatus(`Previewing color ${rgbToHex(...newColor)}...`);
        }

        /**
         * Handles input from the native color picker within the custom color picker.
         * Updates the HSL display and triggers live preview.
         */
        function handleNativeColorPickerInput() {
            const newColor = hexToRgb(nativeColorPickerInCustom.value);
            hslCurrentColorDisplay.style.backgroundColor = nativeColorPickerInCustom.value;
            handleLivePreview(newColor);
        }

        /**
         * Updates HSL slider values and triggers live preview based on HSL changes.
         */
        function updateHslSlidersAndImage() {
            const h = parseInt(hslH.value);
            const s = parseInt(hslS.value);
            const l = parseInt(hslL.value);

            hslHValue.textContent = h;
            hslSValue.textContent = `${s}%`;
            hslLValue.textContent = `${l}%`;

            const newColor = hslToRgb(h, s, l);
            const hex = rgbToHex(...newColor);
            hslCurrentColorDisplay.style.backgroundColor = hex;
            nativeColorPickerInCustom.value = hex; // Keep native picker in sync
            handleLivePreview(newColor);
        }

        /**
         * Finalizes the color change, updating the palette and recalculating PSNR.
         */
        function finalizeColorChange() {
            if (!originalColorForEditing || !previewColor) return;

            // Find the index of the original color in the current palette
            const oldColorStr = JSON.stringify(originalColorForEditing);
            const indexToUpdate = currentPalette.findIndex(p => JSON.stringify(p) === oldColorStr);

            if (indexToUpdate > -1) {
                currentPalette[indexToUpdate] = previewColor; // Update the palette with the new color
            }

            // Redraw the palette display to reflect the change
            displayPalette(currentPalette);

            // Recalculate PSNR with the updated quantized image
            const psnr = calculatePSNR(originalImageData, currentQuantizedImageData);
            psnrValueEl.innerHTML = isFinite(psnr) ? `${psnr.toFixed(2)} dB` : `&infin;`;

            updateStatus(`Color updated to ${rgbToHex(...previewColor)}.`, false);
            customColorPicker.classList.add('hidden'); // Hide the color picker
            originalColorForEditing = null; // Reset state
            previewColor = null;
        }

        /**
         * Cancels the color change, reverting the quantized image to its state before editing.
         */
        function cancelColorChange() {
            if (!originalColorForEditing || !previewColor) return;

            // Revert the color in the current quantized image data
            replaceColorInImageData(currentQuantizedImageData, previewColor, originalColorForEditing);

            updateStatus('Color change cancelled.', false);
            customColorPicker.classList.add('hidden'); // Hide the color picker
            originalColorForEditing = null; // Reset state
            previewColor = null;
        }

        /**
         * Converts RGB color values to a hexadecimal string.
         * @param {number} r - Red component (0-255).
         * @param {number} g - Green component (0-255).
         * @param {number} b - Blue component (0-255).
         * @returns {string} The hexadecimal color string (e.g., "#RRGGBB").
         */
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        /**
         * Converts a hexadecimal color string to RGB values.
         * @param {string} hex - The hexadecimal color string (e.g., "#RRGGBB").
         * @returns {number[]} An array of [R, G, B] values.
         */
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b];
        }

        /**
         * Converts RGB color values to HSL (Hue, Saturation, Lightness).
         * @param {number} r - Red component (0-255).
         * @param {number} g - Green component (0-255).
         * @param {number} b - Blue component (0-255).
         * @returns {number[]} An array of [H, S, L] values (H: 0-360, S: 0-100, L: 0-100).
         */
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];
        }

        /**
         * Converts HSL color values to RGB.
         * @param {number} h - Hue (0-360).
         * @param {number} s - Saturation (0-100).
         * @param {number} l - Lightness (0-100).
         * @returns {number[]} An array of [R, G, B] values (0-255).
         */
        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;

            let r, g, b;

            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        /**
         * Handles the export of the current color palette.
         * Creates a text file with hex codes and triggers a download.
         */
        function handleExportPalette() {
            if (!currentPalette || currentPalette.length === 0) {
                updateStatus('No palette to export.', true);
                return;
            }

            const paletteText = currentPalette.map(color => rgbToHex(...color)).join('\n');
            const blob = new Blob([paletteText], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `color_palette_${colorSlider.value}_colors.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            updateStatus('Palette exported successfully!');
        }

        /**
         * Runs a full analysis, calculating PSNR for color counts from 2 up to the current slider value.
         * Displays results in a table.
         */
        async function runFullAnalysis() {
            if (!originalImageData) {
                updateStatus('Please upload an image first.', true);
                return;
            }

            runFullAnalysisBtn.disabled = true;
            colorSlider.disabled = true;
            exportPaletteBtn.disabled = true;
            algorithmSelect.disabled = true; // Disable during full analysis
            fullAnalysisResults.classList.remove('hidden');
            analysisTableBody.innerHTML = ''; // Clear previous results

            const maxColors = parseInt(colorSlider.value, 10);
            let previousPsnr = null;
            const algorithm = algorithmSelect.value;
            const algorithmDescription = algorithmSelect.options[algorithmSelect.selectedIndex].textContent;


            for (let k = 2; k <= maxColors; k++) {
                updateStatus(`Running full analysis: Processing for ${k} colors (${algorithmDescription})...`);
                // Use a small delay to allow UI to update and prevent browser freezing
                await new Promise(resolve => setTimeout(resolve, 10));

                try {
                    let quantizedResult;
                    if (algorithm === 'median-cut') {
                        quantizedResult = quantizeMedianCut(originalImageData, k);
                    } else if (algorithm === 'k-means') {
                        quantizedResult = quantizeKMeans(originalImageData, k);
                    } else if (algorithm === 'neuquant') {
                        quantizedResult = quantizeNeuQuant(originalImageData, k);
                    } else if (algorithm === 'octree') {
                        quantizedResult = quantizeOctree(originalImageData, k);
                    }
                    else {
                        throw new Error('Unknown quantization algorithm selected.');
                    }

                    const tempQuantizedImageData = new ImageData(
                        new Uint8ClampedArray(quantizedResult.quantizedData.data),
                        quantizedResult.quantizedData.width,
                        quantizedResult.quantizedData.height
                    );
                    const psnr = calculatePSNR(originalImageData, tempQuantizedImageData);

                    const row = analysisTableBody.insertRow();
                    row.className = 'border-b border-gray-100';

                    const cellColorCount = row.insertCell();
                    cellColorCount.className = 'px-4 py-2';
                    cellColorCount.textContent = k;

                    const cellPsnr = row.insertCell();
                    cellPsnr.className = 'px-4 py-2';
                    cellPsnr.textContent = isFinite(psnr) ? psnr.toFixed(2) : '∞';

                    const cellDelta = row.insertCell();
                    cellDelta.className = 'px-4 py-2';

                    if (previousPsnr !== null && isFinite(psnr) && isFinite(previousPsnr)) {
                        const delta = psnr - previousPsnr;
                        cellDelta.textContent = delta.toFixed(2);
                        cellDelta.classList.add(delta >= 0 ? 'delta-positive' : 'delta-negative');
                    } else {
                        cellDelta.textContent = 'N/A';
                    }
                    previousPsnr = psnr;

                    // Scroll to the latest entry
                    analysisTableBody.scrollTop = analysisTableBody.scrollHeight;

                } catch (error) {
                    console.error(`Error during full analysis for ${k} colors:`, error);
                    const row = analysisTableBody.insertRow();
                    row.className = 'border-b border-gray-100 text-red-600';
                    row.insertCell().textContent = k;
                    row.insertCell().textContent = 'Error';
                    row.insertCell().textContent = 'Error';
                    updateStatus(`An error occurred during analysis for ${k} colors.`, true);
                    break; // Stop analysis on error
                }
            }
            updateStatus('Full analysis complete!');
            runFullAnalysisBtn.disabled = false;
            colorSlider.disabled = false;
            exportPaletteBtn.disabled = false;
            algorithmSelect.disabled = false; // Re-enable after full analysis
        }
    </script>
</body>

</html>
