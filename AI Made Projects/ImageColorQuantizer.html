<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Image Color Quantizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .custom-file-button input[type="file"] {
            display: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5;
            /* indigo-600 */
            cursor: pointer;
            border-radius: 50%;
            transition: background .2s;
        }

        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5;
            /* indigo-600 */
            cursor: pointer;
            border-radius: 50%;
            border: 0;
        }

        input[type=range]:disabled::-webkit-slider-thumb {
            background: #9ca3af;
            /* gray-400 */
        }

        input[type=range]:disabled::-moz-range-thumb {
            background: #9ca3af;
            /* gray-400 */
        }

        /* --- New Palette Styling --- */
        .palette-swatch {
            width: 100%;
            padding-top: 100%;
            /* 1:1 Aspect Ratio */
            position: relative;
            border-radius: 0.5rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
            cursor: pointer;
            overflow: hidden;
            transition: transform 0.2s ease;
        }

        .palette-swatch:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        .palette-swatch span {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.8);
            color: #1f2937;
            opacity: 0;
            /* Hidden by default */
            transition: opacity 0.2s;
        }

        .palette-swatch:hover span {
            opacity: 1;
            /* Show on hover */
        }
        
        /* --- Styles for Delete Button --- */
        .delete-color-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: #ef4444; /* red-500 */
            color: white;
            border-radius: 50%;
            border: 1px solid white;
            font-size: 14px;
            line-height: 18px; /* Adjust for vertical centering */
            text-align: center;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.2s ease;
            z-index: 20; /* Make sure it's above other elements */
        }

        .palette-swatch:hover .delete-color-btn {
            opacity: 1;
            transform: scale(1);
        }

        .delete-color-btn:hover {
            background-color: #dc2626; /* red-600 */
        }


        #analysisTableContainer {
            max-height: 400px;
            overflow-y: auto;
        }

        #customColorPicker {
            position: absolute;
            z-index: 1000;
        }

        #nativeColorPickerInCustom {
            width: 100%;
            height: 40px;
            border: 1px solid #ccc;
            border-radius: 0.5rem;
            cursor: pointer;
            padding: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        #nativeColorPickerInCustom::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        #nativeColorPickerInCustom::-webkit-color-swatch {
            border: none;
            border-radius: 0.5rem;
        }

        #nativeColorPickerInCustom::-moz-color-swatch {
            border: none;
            border-radius: 0.5rem;
        }

        .delta-positive {
            color: #16a34a;
        }

        /* green-600 */
        .delta-negative {
            color: #dc2626;
        }

        /* red-600 */

        /* Drag and Drop styles */
        .drag-over {
            border: 2px dashed #6366f1;
            /* indigo-500 */
            background-color: #eef2ff;
            /* indigo-50 */
        }

        /* Pixel art rendering for canvases and images */
        canvas, img {
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimize-contrast;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }
    </style>
</head>

<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">

    <div id="appContainer" class="w-full max-w-5xl bg-white rounded-xl shadow-lg p-6 md:p-8">
        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Advanced Color Quantizer</h1>
            <p class="text-gray-600 mt-2">Reduce colors, view palettes, and measure image quality with PSNR.</p>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6 items-end">
            <div class="flex flex-col">
                <label for="imageUpload" class="mb-2 font-semibold text-gray-700">1. Upload Image</label>
                <div class="custom-file-button">
                    <label for="imageUpload"
                        class="w-full inline-flex items-center justify-center px-4 py-2 bg-gray-200 text-gray-700 rounded-lg cursor-pointer hover:bg-gray-300 transition-colors">
                        <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                            xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
                        </svg>
                        <span id="fileName">Choose a PNG file...</span>
                    </label>
                    <input id="imageUpload" type="file" accept="image/png">
                </div>
                <p class="text-sm text-gray-500 mt-2">Or drag & drop / paste a PNG image anywhere on the page.</p>
            </div>
            <div class="flex flex-col">
                <label for="colorSlider" class="mb-2 font-semibold text-gray-700">2. Number of Colors</label>
                <div class="flex items-center space-x-4">
                    <input id="colorSlider" type="range" min="2" max="256" value="16"
                        class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer" disabled>
                    <span id="sliderValue"
                        class="font-semibold text-gray-700 w-16 text-center bg-gray-100 rounded-md py-1">16</span>
                </div>
            </div>
        </div>

        <!-- Algorithm Selection Dropdown -->
        <div class="mb-6">
            <label for="algorithmSelect" class="block mb-2 font-semibold text-gray-700">3. Select Algorithm</label>
            <select id="algorithmSelect"
                class="block w-full px-4 py-2 bg-white border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-200 disabled:cursor-not-allowed"
                disabled>
                <option value="median-cut">Median Cut - Speed+ Quality+</option>
                <option value="k-means">K-means clustering - Quality++ Speed-</option>
                <option value="neuquant">NeuQuant - Speed++ Quality-- Output Size--</option>
                <option value="octree">Octree - Speed++ Quality-</option>
            </select>
        </div>

        <!-- Dithering Checkbox -->
        <div class="mb-6">
            <label for="ditheringCheckbox" class="flex items-center">
                <input type="checkbox" id="ditheringCheckbox"
                    class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" disabled>
                <span class="ml-2 text-gray-700">Apply error diffusion dithering (Floyd-Steinberg)</span>
            </label>
        </div>


        <div id="status" class="text-center my-4 text-lg text-gray-600 h-6"></div>

        <div id="resultContainer" class="grid grid-cols-1 md:grid-cols-2 gap-8 hidden">
            <div>
                <h2 class="text-xl font-semibold text-center mb-4">Original Image <span id="originalImageSize"
                        class="text-base text-gray-500 font-normal"></span></h2>
                <canvas id="originalCanvas" class="w-full h-auto rounded-lg shadow-md border border-gray-200"></canvas>
            </div>
            <div>
                <h2 class="text-xl font-semibold text-center mb-4">Quantized Image <span id="quantizedImageSize"
                        class="text-base text-gray-500 font-normal"></span></h2>
                <div class="relative">
                    <canvas id="quantizedCanvas" class="w-full h-auto rounded-lg shadow-md border border-gray-200 hidden"></canvas>
                    <img id="quantizedImage" class="w-full h-auto rounded-lg shadow-md border border-gray-200" alt="Quantized Image Output">
                </div>
                <!-- PSNR (Quality) widget moved here -->
                <div class="mt-4 bg-gray-50 p-4 rounded-lg shadow-sm">
                    <h4 class="font-semibold mb-2 text-gray-800">Current Quality</h4>
                    <div class="flex justify-between items-center">
                        <span class="font-medium text-gray-700">PSNR (Quality):</span>
                        <span id="psnrValue" class="font-bold text-lg text-indigo-600">N/A</span>
                    </div>
                    <p class="text-sm text-gray-500 mt-2">Peak Signal-to-Noise Ratio. Higher is better. &infin;
                        indicates a perfect match.</p>
                </div>
            </div>
        </div>

        <div id="analysisContainer" class="mt-8 hidden">
            <h3 class="text-xl font-semibold mb-2">Analysis</h3>
            <div class="mb-6 border-b border-gray-200 pb-6">
                <button id="runFullAnalysisBtn"
                    class="bg-teal-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed"
                    disabled>Run Full Analysis</button>
                <p class="text-sm text-gray-500 mt-2">Click to calculate the image quality (PSNR) for every color count
                    from 2 up to the current slider value. Results will appear in a table below.</p>
            </div>

            <div class="grid grid-cols-1">
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="font-semibold text-gray-800">Current Palette</h4>
                        <button id="exportPaletteBtn"
                            class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed"
                            disabled>Export Palette</button>
                    </div>
                    <div id="paletteContainer"
                        class="grid grid-cols-8 sm:grid-cols-12 md:grid-cols-16 gap-2 bg-gray-50 p-4 rounded-lg">
                    </div>

                    <!-- Custom Palette Upload Section -->
                    <div class="mt-6 pt-4 border-t border-gray-200">
                        <h4 class="font-semibold text-gray-800 mb-2">Upload Custom Palette</h4>
                        <div class="flex items-center space-x-2">
                            <div class="custom-file-button flex-grow">
                                <label for="paletteUpload"
                                    class="w-full inline-flex items-center justify-center px-4 py-2 bg-gray-200 text-gray-700 rounded-lg cursor-pointer hover:bg-gray-300 transition-colors">
                                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M7 16a4 4 0 01-.88-7.903A5 5 0 0115.9 6L16 6a3 3 0 013 3v10a2 2 0 01-2 2H7a2 2 0 01-2-2v-1a1 1 0 011-1h1z">
                                        </path>
                                    </svg>
                                    <span id="paletteFileName">Upload Palette (TXT)...</span>
                                </label>
                                <input id="paletteUpload" type="file" accept=".txt">
                            </div>
                        </div>
                        <p class="text-sm text-gray-500 mt-2">Upload a .txt file with hex (#RRGGBB or RRGGBB) or RGB
                            (R,G,B) colors, one per line.</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="fullAnalysisResults" class="mt-8 hidden">
            <h3 class="text-xl font-semibold mb-4">Full Analysis Results</h3>
            <div id="analysisTableContainer" class="w-full bg-gray-50 p-4 rounded-lg border">
                <table class="w-full text-left table-auto">
                    <thead>
                        <tr class="border-b-2 border-gray-200">
                            <th class="px-4 py-2">Color Count</th>
                            <th class="px-4 py-2">PSNR (dB)</th>
                            <th class="px-4 py-2">Delta from Previous</th>
                        </tr>
                    </thead>
                    <tbody id="analysisTableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="customColorPicker" class="hidden bg-white shadow-xl p-4 rounded-lg z-10 border border-gray-200"
        style="min-width: 250px;">
        <div class="flex mb-4 border-b">
            <button id="rgbTabBtn"
                class="px-3 py-2 text-sm font-medium text-indigo-700 border-b-2 border-indigo-500 focus:outline-none">RGB</button>
            <button id="hslTabBtn"
                class="px-3 py-2 text-sm font-medium text-gray-500 hover:text-gray-700 border-b-2 border-transparent focus:outline-none">HSL</button>
        </div>

        <div id="rgbPanel">
            <label for="nativeColorPickerInCustom" class="block text-xs font-medium text-gray-700 mb-2">Select RGB
                Color:</label>
            <input type="color" id="nativeColorPickerInCustom" value="#000000">
        </div>

        <div id="hslPanel" class="hidden">
            <div class="mb-2">
                <label for="hslH" class="block text-xs font-medium text-gray-700">Hue:</label>
                <input type="range" id="hslH" min="0" max="360" value="0"
                    class="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    style="background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red);">
                <span id="hslHValue" class="text-xs text-gray-600">0</span>
            </div>
            <div class="mb-2">
                <label for="hslS" class="block text-xs font-medium text-gray-700">Saturation:</label>
                <input type="range" id="hslS" min="0" max="100" value="0"
                    class="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    style="background: linear-gradient(to right, gray, #ff0000);">
                <span id="hslSValue" class="text-xs text-gray-600">0</span>
            </div>
            <div class="mb-2">
                <label for="hslL" class="block text-xs font-medium text-gray-700">Lightness:</label>
                <input type="range" id="hslL" min="0" max="100" value="0"
                    class="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    style="background: linear-gradient(to right, black, gray, white);">
                <span id="hslLValue" class="text-xs text-gray-600">0</span>
            </div>
            <div id="hslCurrentColorDisplay" class="w-full h-8 mt-4 rounded-lg border border-gray-200"></div>
        </div>

        <div class="flex justify-between gap-2 mt-4">
            <button id="confirmColorBtn"
                class="flex-1 bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105">Confirm</button>
            <button id="cancelColorBtn"
                class="flex-1 bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-transform transform hover:scale-105">Cancel</button>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js"></script>
    <script>
        // --- DOM Element References ---
        const imageUpload = document.getElementById('imageUpload');
        const colorSlider = document.getElementById('colorSlider');
        const sliderValueEl = document.getElementById('sliderValue');
        const originalCanvas = document.getElementById('originalCanvas');
        const quantizedCanvas = document.getElementById('quantizedCanvas');
        const quantizedImage = document.getElementById('quantizedImage');
        const statusEl = document.getElementById('status');
        const resultContainer = document.getElementById('resultContainer');
        const fileNameEl = document.getElementById('fileName');
        const analysisContainer = document.getElementById('analysisContainer');
        const psnrValueEl = document.getElementById('psnrValue');
        const paletteContainer = document.getElementById('paletteContainer');
        const exportPaletteBtn = document.getElementById('exportPaletteBtn');
        const runFullAnalysisBtn = document.getElementById('runFullAnalysisBtn');
        const fullAnalysisResults = document.getElementById('fullAnalysisResults');
        const analysisTableBody = document.getElementById('analysisTableBody');
        const originalImageSizeEl = document.getElementById('originalImageSize');
        const quantizedImageSizeEl = document.getElementById('quantizedImageSize');
        const appContainer = document.getElementById('appContainer');
        const algorithmSelect = document.getElementById('algorithmSelect');
        const ditheringCheckbox = document.getElementById('ditheringCheckbox');

        // New palette upload elements
        const paletteUpload = document.getElementById('paletteUpload');
        const paletteFileNameEl = document.getElementById('paletteFileName');


        const originalCtx = originalCanvas.getContext('2d');
        const quantizedCtx = quantizedCanvas.getContext('2d');
        let originalImageData = null;
        let currentPalette = [];
        let debounceTimer;
        let currentImageFile = null;
        let isCustomPaletteActive = false;
        let currentObjectUrl = null;

        // --- State variables for color editing ---
        let currentQuantizedImageData = null;
        let originalColorForEditing = null;
        let latestPreviewColor = null;
        let preEditImageData = null;
        let currentEditedSwatch = null;

        // --- Custom Color Picker DOM Elements ---
        const customColorPicker = document.getElementById('customColorPicker');
        const rgbTabBtn = document.getElementById('rgbTabBtn');
        const hslTabBtn = document.getElementById('hslTabBtn');
        const rgbPanel = document.getElementById('rgbPanel');
        const hslPanel = document.getElementById('hslPanel');
        const confirmColorBtn = document.getElementById('confirmColorBtn');
        const cancelColorBtn = document.getElementById('cancelColorBtn');
        const nativeColorPickerInCustom = document.getElementById('nativeColorPickerInCustom');
        const hslH = document.getElementById('hslH');
        const hslS = document.getElementById('hslS');
        const hslL = document.getElementById('hslL');
        const hslHValue = document.getElementById('hslHValue');
        const hslSValue = document.getElementById('hslSValue');
        const hslLValue = document.getElementById('hslLValue');
        const hslCurrentColorDisplay = document.getElementById('hslCurrentColorDisplay');

        // --- Event Listeners ---
        imageUpload.addEventListener('change', (e) => handleImageFile(e.target.files[0]));
        colorSlider.addEventListener('input', handleSliderChange);
        exportPaletteBtn.addEventListener('click', handleExportPalette);
        runFullAnalysisBtn.addEventListener('click', runFullAnalysis);
        rgbTabBtn.addEventListener('click', () => switchColorPickerTab('rgb'));
        hslTabBtn.addEventListener('click', () => switchColorPickerTab('hsl'));
        nativeColorPickerInCustom.addEventListener('input', handleNativeColorPickerInput);
        hslH.addEventListener('input', updateHslSlidersAndImage);
        hslS.addEventListener('input', updateHslSlidersAndImage);
        hslL.addEventListener('input', updateHslSlidersAndImage);
        confirmColorBtn.addEventListener('click', finalizeColorChange);
        cancelColorBtn.addEventListener('click', cancelColorChange);
        algorithmSelect.addEventListener('change', startQuantization);
        ditheringCheckbox.addEventListener('change', startQuantization);
        paletteUpload.addEventListener('change', (e) => handlePaletteUpload(e.target.files[0]));


        // Drag and Drop / Paste Listeners
        document.addEventListener('DOMContentLoaded', () => {
            document.body.addEventListener('dragover', preventDefaults, false);
            document.body.addEventListener('dragleave', preventDefaults, false);
            document.body.addEventListener('drop', preventDefaults, false);
            document.body.addEventListener('dragenter', () => appContainer.classList.add('drag-over'), false);
            document.body.addEventListener('dragleave', () => appContainer.classList.remove('drag-over'), false);
            document.body.addEventListener('drop', (e) => {
                appContainer.classList.remove('drag-over');
                handleDrop(e);
            }, false);
            document.body.addEventListener('paste', handlePaste, false);
        });

        const debouncedQuantize = debounce(startQuantization, 250);

        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

        function handleImageFile(file) {
            if (!file || !file.type.startsWith('image/')) {
                updateStatus('Please select or drop/paste a valid image file.', true);
                return;
            }
            currentImageFile = file;
            fileNameEl.textContent = file.name.length > 20 ? `${file.name.substring(0, 17)}...` : file.name;
            originalImageSizeEl.textContent = `(${formatBytes(file.size)})`;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalCanvas.width = img.width;
                    originalCanvas.height = img.height;
                    quantizedCanvas.width = img.width;
                    quantizedCanvas.height = img.height;
                    [originalCtx, quantizedCtx].forEach(ctx => { ctx.imageSmoothingEnabled = false; });
                    originalCtx.drawImage(img, 0, 0);
                    originalImageData = originalCtx.getImageData(0, 0, img.width, img.height);
                    resultContainer.classList.remove('hidden');
                    analysisContainer.classList.remove('hidden');
                    fullAnalysisResults.classList.add('hidden');

                    setControlsEnabled(true);
                    isCustomPaletteActive = false; 
                    paletteFileNameEl.textContent = 'Upload Palette (TXT)...';
                    updateStatus('Image loaded. Ready to quantize.');
                    startQuantization();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function handleDrop(e) {
            preventDefaults(e);
            if (e.dataTransfer.files.length > 0) handleImageFile(e.dataTransfer.files[0]);
        }

        function handlePaste(e) {
            preventDefaults(e);
            for (const item of e.clipboardData.items) {
                if (item.type.indexOf('image') !== -1) {
                    const file = item.getAsFile();
                    if (file) { handleImageFile(file); return; }
                }
            }
            updateStatus('No image found in clipboard.', true);
        }

        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        function debounce(func, delay) {
            return function (...args) {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => func.apply(this, args), delay);
            };
        }

        function handleSliderChange() {
            sliderValueEl.textContent = colorSlider.value;
            if (originalImageData) {
                startQuantization();
            }
        }

        function updateStatus(message, isError = false) {
            statusEl.textContent = message;
            statusEl.style.color = isError ? '#dc2626' : '#4b5563';
        }

        function setControlsEnabled(enabled) {
            colorSlider.disabled = !enabled;
            algorithmSelect.disabled = !enabled;
            runFullAnalysisBtn.disabled = !enabled;
            exportPaletteBtn.disabled = !enabled;
            ditheringCheckbox.disabled = !enabled;
            paletteUpload.disabled = !enabled;
        }

        function startQuantization() {
            if (!originalImageData) return;

            isCustomPaletteActive = false;
            paletteFileNameEl.textContent = 'Upload Palette (TXT)...';

            const k = parseInt(colorSlider.value, 10);
            const algorithm = algorithmSelect.value;
            const useDithering = ditheringCheckbox.checked;
            let algorithmDescription = algorithmSelect.options[algorithmSelect.selectedIndex].textContent;
            updateStatus(`Processing for ${k} colors using ${algorithmDescription}...`);

            setTimeout(() => {
                try {
                    let paletteResult;
                    let finalImageData;

                    if (algorithm === 'median-cut') {
                        paletteResult = quantizeMedianCut(originalImageData, k);
                        finalImageData = mapPixelsToPaletteKMeans(originalImageData, getUniquePalette(paletteResult.palette));
                    } else if (algorithm === 'k-means') {
                        paletteResult = quantizeKMeans(originalImageData, k);
                        finalImageData = mapPixelsToPaletteKMeans(originalImageData, getUniquePalette(paletteResult.palette));
                    } else if (algorithm === 'neuquant') {
                        paletteResult = quantizeNeuQuant(originalImageData, k);
                        finalImageData = mapPixelsToPaletteKMeans(originalImageData, getUniquePalette(paletteResult.palette));
                    } else if (algorithm === 'octree') {
                        const octreeOutput = quantizeOctree(originalImageData, k);
                        paletteResult = { palette: octreeOutput.palette };
                        finalImageData = octreeOutput.quantizedData;
                    } else {
                        throw new Error('Unknown quantization algorithm selected.');
                    }

                    const uniquePalette = getUniquePalette(paletteResult.palette);
                    currentPalette = uniquePalette;

                    if (useDithering) {
                        updateStatus('Applying dithering...');
                        const ditheredImageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
                        applyErrorDiffusion(ditheredImageData, uniquePalette);
                        finalImageData = ditheredImageData;
                    }

                    updateQuantizedImageDetails(finalImageData);
                    displayPalette(currentPalette);
                    updateStatus(`Image quantized to ${currentPalette.length} unique colors.`);
                } catch (error) {
                    console.error("Quantization error:", error);
                    updateStatus('An error occurred during quantization: ' + error.message, true);
                }
            }, 10);
        }
        
        function updateQuantizedImageDetails(quantizedImageData) {
            currentQuantizedImageData = quantizedImageData;

            const psnr = calculatePSNR(originalImageData, currentQuantizedImageData);
            psnrValueEl.innerHTML = isFinite(psnr) ? `${psnr.toFixed(2)} dB` : `&infin;`;
            
            let indexedPngBuffer;
            try {
                indexedPngBuffer = UPNG.encode([quantizedImageData.data.buffer], quantizedImageData.width, quantizedImageData.height, currentPalette.length);
            } catch (e) {
                console.error("PNG Encoding Error:", e);
                updateStatus("Error creating indexed PNG.", true);
                quantizedImageSizeEl.textContent = `(Error)`;
                return;
            }
            
            if (currentObjectUrl) {
                URL.revokeObjectURL(currentObjectUrl);
            }
            const blob = new Blob([indexedPngBuffer], { type: 'image/png' });
            currentObjectUrl = URL.createObjectURL(blob);
            quantizedImage.src = currentObjectUrl;

            quantizedImageSizeEl.textContent = `(${formatBytes(indexedPngBuffer.byteLength)})`;
            exportPaletteBtn.disabled = false;
        }

        function getUniquePalette(palette) {
            const uniqueColors = new Map();
            for (const color of palette) {
                const key = color.join(',');
                if (!uniqueColors.has(key)) uniqueColors.set(key, color);
            }
            return Array.from(uniqueColors.values());
        }

        // --- DITHERING IMPLEMENTATION ---
        function applyErrorDiffusion(imageData, palette) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            const buffer = new Float32Array(data.length);
            for (let i = 0; i < data.length; i++) buffer[i] = data[i];

            const diffuse = (nx, ny, errR, errG, errB, factor) => {
                if (nx < 0 || nx >= width || ny < 0 || ny >= height) return;
                const nIdx = (ny * width + nx) * 4;
                buffer[nIdx] += errR * factor;
                buffer[nIdx + 1] += errG * factor;
                buffer[nIdx + 2] += errB * factor;
            };

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const oldR = buffer[idx], oldG = buffer[idx + 1], oldB = buffer[idx + 2];
                    const [newR, newG, newB] = findClosestColor([oldR, oldG, oldB], palette);
                    data[idx] = newR; data[idx + 1] = newG; data[idx + 2] = newB;
                    const errR = oldR - newR, errG = oldG - newG, errB = oldB - newB;
                    diffuse(x + 1, y, errR, errG, errB, 7 / 16);
                    diffuse(x - 1, y + 1, errR, errG, errB, 3 / 16);
                    diffuse(x, y + 1, errR, errG, errB, 5 / 16);
                    diffuse(x + 1, y + 1, errR, errG, errB, 1 / 16);
                }
            }
        }


        // --- QUANTIZATION ALGORITHMS (and their helpers) ---

        function quantizeMedianCut(imageData, k) {
            const pixels = getPixelsMedianCut(imageData);
            if (pixels.length === 0) return { palette: [] };
            const initialBucket = [pixels];
            const buckets = splitBucketsMedianCut(initialBucket, k);
            const palette = buckets.filter(b => b.length > 0).map(getAverageColorMedianCut);
            return { palette };
        }

        function quantizeKMeans(imageData, k, maxIterations = 20) {
            const pixels = getPixelsRGB(imageData);
            if (pixels.length === 0) return { palette: [] };
            if (k > pixels.length) k = pixels.length;
            let centroids = [];
            const pixelIndices = Array.from({ length: pixels.length }, (_, i) => i);
            for (let i = 0; i < k; i++) {
                const randomIndex = pixelIndices.splice(Math.floor(Math.random() * pixelIndices.length), 1)[0];
                centroids.push([...pixels[randomIndex]]);
            }
            let assignments = new Uint32Array(pixels.length);
            let changed = true;
            for (let iteration = 0; changed && iteration < maxIterations; iteration++) {
                changed = false;
                for (let i = 0; i < pixels.length; i++) {
                    const pixel = pixels[i];
                    let minDistanceSquared = Infinity, closestCentroidIndex = -1;
                    for (let j = 0; j < k; j++) {
                        const dist = (pixel[0] - centroids[j][0]) ** 2 + (pixel[1] - centroids[j][1]) ** 2 + (pixel[2] - centroids[j][2]) ** 2;
                        if (dist < minDistanceSquared) { minDistanceSquared = dist; closestCentroidIndex = j; }
                    }
                    if (assignments[i] !== closestCentroidIndex) { assignments[i] = closestCentroidIndex; changed = true; }
                }
                const newCentroids = Array.from({ length: k }, () => [0, 0, 0, 0]);
                for (let i = 0; i < pixels.length; i++) {
                    const pixel = pixels[i], centroidIndex = assignments[i];
                    if (centroidIndex !== -1) {
                        newCentroids[centroidIndex][0] += pixel[0]; newCentroids[centroidIndex][1] += pixel[1];
                        newCentroids[centroidIndex][2] += pixel[2]; newCentroids[centroidIndex][3]++;
                    }
                }
                for (let i = 0; i < k; i++) {
                    if (newCentroids[i][3] > 0) {
                        centroids[i] = [Math.round(newCentroids[i][0] / newCentroids[i][3]), Math.round(newCentroids[i][1] / newCentroids[i][3]), Math.round(newCentroids[i][2] / newCentroids[i][3])];
                    } else {
                        centroids[i] = [...pixels[Math.floor(Math.random() * pixels.length)]];
                        changed = true;
                    }
                }
            }
            return { palette: centroids };
        }

        function quantizeNeuQuant(imageData, k, initialLearningRate = 0.2, initialRadius = 30, maxIterations = 30 * k) {
            const pixels = getPixelsRGB(imageData);
            if (pixels.length === 0) return { palette: [] };
            const colorMap = Array.from({ length: k }, () => [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)]);
            const numIters = Math.min(pixels.length, maxIterations), tau = numIters;
            for (let i = 0; i < numIters; i++) {
                const currentPixel = pixels[Math.floor(Math.random() * pixels.length)];
                const learningRate = initialLearningRate * Math.exp(-i / tau), radius = initialRadius * Math.exp(-i / tau);
                let bmuIndex = 0, minDist = Infinity;
                for (let j = 0; j < k; j++) {
                    const dist = weightedRgbDistance(currentPixel, colorMap[j]);
                    if (dist < minDist) { minDist = dist; bmuIndex = j; }
                }
                const bmuColor = colorMap[bmuIndex];
                for (let j = 0; j < k; j++) {
                    const neighbourDist = weightedRgbDistance(colorMap[j], bmuColor);
                    if (neighbourDist <= radius) {
                        const influence = Math.exp(-(neighbourDist * neighbourDist) / (2 * radius * radius)), alpha = learningRate * influence;
                        colorMap[j][0] = clamp(colorMap[j][0] + alpha * (currentPixel[0] - colorMap[j][0]));
                        colorMap[j][1] = clamp(colorMap[j][1] + alpha * (currentPixel[1] - colorMap[j][1]));
                        colorMap[j][2] = clamp(colorMap[j][2] + alpha * (currentPixel[2] - colorMap[j][2]));
                    }
                }
            }
            return { palette: colorMap };
        }

        class MinHeap {
            constructor() { this.heap = []; }
            isEmpty() { return this.heap.length === 0; }
            push(node) { this.heap.push(node); this.bubbleUp(this.heap.length - 1); }
            pop() { if (this.isEmpty()) return null; const min = this.heap[0]; const last = this.heap.pop(); if (this.heap.length > 0) { this.heap[0] = last; this.sinkDown(0); } return min; }
            bubbleUp(index) { while (index > 0) { const parentIndex = Math.floor((index - 1) / 2); if (this.heap[parentIndex].pixelCount > this.heap[index].pixelCount) { [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]]; index = parentIndex; } else { break; } } }
            sinkDown(index) { const leftChildIndex = 2 * index + 1; const rightChildIndex = 2 * index + 2; let smallestIndex = index; if (leftChildIndex < this.heap.length && this.heap[leftChildIndex].pixelCount < this.heap[smallestIndex].pixelCount) { smallestIndex = leftChildIndex; } if (rightChildIndex < this.heap.length && this.heap[rightChildIndex].pixelCount < this.heap[smallestIndex].pixelCount) { smallestIndex = rightChildIndex; } if (smallestIndex !== index) { [this.heap[smallestIndex], this.heap[index]] = [this.heap[index], this.heap[smallestIndex]]; this.sinkDown(smallestIndex); } }
        }

        class OctreeNode {
            constructor(level, parent) { this.children = new Array(8).fill(null); this.isLeaf = true; this.pixelCount = 0; this.redSum = 0; this.greenSum = 0; this.blueSum = 0; this.paletteIndex = -1; this.level = level; this.parent = parent; }
            addPixel(pixel, level, reducibleHeaps) { if (!this.isLeaf) { const childIndex = getOctreeChildIndex(pixel, level); if (!this.children[childIndex]) { this.children[childIndex] = new OctreeNode(level + 1, this); } this.children[childIndex].addPixel(pixel, level + 1, reducibleHeaps); return; } if (level === 7) { this.pixelCount++; this.redSum += pixel[0]; this.greenSum += pixel[1]; this.blueSum += pixel[2]; return; } if (this.pixelCount > 0) { const oldColor = [this.redSum / this.pixelCount, this.greenSum / this.pixelCount, this.blueSum / this.pixelCount]; const oldIndex = getOctreeChildIndex(oldColor, level); this.children[oldIndex] = new OctreeNode(level + 1, this); this.children[oldIndex].pixelCount = this.pixelCount; this.children[oldIndex].redSum = this.redSum; this.children[oldIndex].greenSum = this.greenSum; this.children[oldIndex].blueSum = this.blueSum; } this.isLeaf = false; this.pixelCount = 0; this.redSum = 0; this.greenSum = 0; this.blueSum = 0; reducibleHeaps[this.level].push(this); const newIndex = getOctreeChildIndex(pixel, level); if (!this.children[newIndex]) { this.children[newIndex] = new OctreeNode(level + 1, this); } this.children[newIndex].addPixel(pixel, level + 1, reducibleHeaps); }
            mergeChildren() { if (this.isLeaf) return; for (let i = 0; i < 8; i++) { const child = this.children[i]; if (child) { this.redSum += child.redSum; this.greenSum += child.greenSum; this.blueSum += child.blueSum; this.pixelCount += child.pixelCount; this.children[i] = null; } } this.isLeaf = true; }
            getLeaves(leaves) { if (this.isLeaf) { if (this.pixelCount) leaves.push(this); } else { for (let i = 0; i < 8; i++) { if (this.children[i]) this.children[i].getLeaves(leaves); } } }
            getAverageColor() { if (this.pixelCount === 0) return [0, 0, 0]; return [Math.round(this.redSum / this.pixelCount), Math.round(this.greenSum / this.pixelCount), Math.round(this.blueSum / this.pixelCount)]; }
        }

        function getOctreeChildIndex(pixel, level) { let index = 0; const bit = 7 - level; if ((pixel[0] >> bit) & 1) index |= 4; if ((pixel[1] >> bit) & 1) index |= 2; if ((pixel[2] >> bit) & 1) index |= 1; return index; }

        function quantizeOctree(imageData, k) {
            const pixels = getPixelsRGB(imageData);
            if (!pixels.length) return { quantizedData: new ImageData(imageData.width, imageData.height), palette: [] };
            const root = new OctreeNode(0, null);
            const reducibleHeaps = Array.from({ length: 8 }, () => new MinHeap());
            for (const pixel of pixels) { root.addPixel(pixel, 0, reducibleHeaps); }
            const leaves = [];
            root.getLeaves(leaves);
            let leafCount = leaves.length;
            if (leafCount > k) {
                let level = 7;
                while (leafCount > k && level >= 0) {
                    while (!reducibleHeaps[level].isEmpty() && leafCount > k) {
                        const node = reducibleHeaps[level].pop();
                        if (!node) continue;
                        const leavesToRemove = [];
                        node.getLeaves(leavesToRemove);
                        const removedLeafCount = leavesToRemove.length;
                        node.mergeChildren();
                        leafCount = leafCount - removedLeafCount + 1;
                        if (node.parent && !node.parent.isLeaf && node.parent.level > 0) { reducibleHeaps[node.parent.level].push(node.parent); }
                    }
                    level--;
                }
            }
            const finalLeaves = [];
            root.getLeaves(finalLeaves);
            const palette = finalLeaves.map(l => l.getAverageColor());
            const newImageData = new ImageData(imageData.width, imageData.height);
            const originalData = imageData.data;
            const newData = newImageData.data;
            for (let i = 0; i < originalData.length; i += 4) {
                const alpha = originalData[i + 3];
                if (alpha < 128) { newData[i] = originalData[i]; newData[i + 1] = originalData[i + 1]; newData[i + 2] = originalData[i + 2]; newData[i + 3] = alpha; continue; }
                const pixel = [originalData[i], originalData[i + 1], originalData[i + 2]];
                let currentNode = root;
                for (let level = 0; level <= 7; level++) { if (currentNode.isLeaf) break; const index = getOctreeChildIndex(pixel, level); if (!currentNode.children[index]) { break; } currentNode = currentNode.children[index]; }
                const closestColor = currentNode.getAverageColor();
                newData[i] = closestColor[0]; newData[i + 1] = closestColor[1]; newData[i + 2] = closestColor[2]; newData[i + 3] = alpha;
            }
            return { quantizedData: newImageData, palette };
        }


        function weightedRgbDistance(a, b) { const dR = a[0] - b[0], dG = a[1] - b[1], dB = a[2] - b[2]; return Math.sqrt(0.30 * dR * dR + 0.59 * dG * dG + 0.11 * dB * dB); }
        function clamp(v) { return Math.min(255, Math.max(0, Math.round(v))); }
        function getPixelsMedianCut(imageData) { const pixels = []; const data = imageData.data; for (let i = 0; i < data.length; i += 4) { if (data[i + 3] > 128) { const rgb = [data[i], data[i + 1], data[i + 2]]; pixels.push({ rgb, lab: rgbToLab(rgb) }); } } return pixels; }
        function getPixelsRGB(imageData) { const pixels = []; const data = imageData.data; for (let i = 0; i < data.length; i += 4) { if (data[i + 3] > 128) pixels.push([data[i], data[i + 1], data[i + 2]]); } return pixels; }
        function splitBucketsMedianCut(buckets, k) { while (buckets.length < k) { let bucketToSplit = -1, maxRange = -1, channelIndexToSplit = -1; for (let i = 0; i < buckets.length; i++) { if (buckets[i].length > 1) { const { range, channelIndex } = findGreatestRangeChannelMedianCut(buckets[i]); if (range > maxRange) { maxRange = range; bucketToSplit = i; channelIndexToSplit = channelIndex; } } } if (bucketToSplit === -1) break; const bucket = buckets[bucketToSplit]; bucket.sort((a, b) => a.lab[channelIndexToSplit] - b.lab[channelIndexToSplit]); const medianIndex = Math.floor(bucket.length / 2); buckets.splice(bucketToSplit, 1, bucket.slice(0, medianIndex), bucket.slice(medianIndex)); } return buckets; }
        function findGreatestRangeChannelMedianCut(bucket) { let min0 = Infinity, max0 = -Infinity, min1 = Infinity, max1 = -Infinity, min2 = Infinity, max2 = -Infinity; for (const p of bucket) { const [L, a, b] = p.lab; if (L < min0) min0 = L; if (L > max0) max0 = L; if (a < min1) min1 = a; if (a > max1) max1 = a; if (b < min2) min2 = b; if (b > max2) max2 = b; } const range0 = max0 - min0, range1 = max1 - min1, range2 = max2 - min2; if (range0 >= range1 && range0 >= range2) return { channelIndex: 0, range: range0 }; if (range1 >= range0 && range1 >= range2) return { channelIndex: 1, range: range1 }; return { channelIndex: 2, range: range2 }; }
        function getAverageColorMedianCut(bucket) { let sumL = 0, sumA = 0, sumB = 0; for (const p of bucket) { sumL += p.lab[0]; sumA += p.lab[1]; sumB += p.lab[2]; } return labToRgb([sumL / bucket.length, sumA / bucket.length, sumB / bucket.length]); }
        function mapPixelsToPaletteMedianCut(original, palette) { const newImageData = new ImageData(original.width, original.height); if (palette.length === 0) return newImageData; const palettePoints = palette.map(rgb => ({ rgb, lab: rgbToLab(rgb) })); const kdTree = buildKdTree(palettePoints); const memo = new Map(); const originalData = original.data, newData = newImageData.data; for (let i = 0; i < originalData.length; i += 4) { const alpha = originalData[i + 3]; if (alpha < 128) { newData[i] = originalData[i]; newData[i + 1] = originalData[i + 1]; newData[i + 2] = originalData[i + 2]; newData[i + 3] = alpha; continue; } const r = originalData[i], g = originalData[i + 1], b = original[i + 2]; const key = (r << 16) | (g << 8) | b; let newColor = memo.get(key); if (!newColor) { newColor = kdNearest(kdTree, rgbToLab([r, g, b])).point.rgb; memo.set(key, newColor); } newData[i] = newColor[0]; newData[i + 1] = newColor[1]; newData[i + 2] = newColor[2]; newData[i + 3] = alpha; } return newImageData; }
        function rgbToXyz([r, g, b]) { let [sr, sg, sb] = [r, g, b].map(v => { v /= 255; return v > 0.04045 ? Math.pow((v + 0.055) / 1.055, 2.4) : v / 12.92; }); return [sr * 0.4124564 + sg * 0.3575761 + sb * 0.1804375, sr * 0.2126729 + sg * 0.7151522 + sb * 0.0721750, sr * 0.0193339 + sg * 0.1191920 + sb * 0.9503041]; }
        function xyzToLab([x, y, z]) { const [Xn, Yn, Zn] = [0.95047, 1.00000, 1.08883]; const f = t => t > 0.008856 ? Math.cbrt(t) : (7.787 * t + 16 / 116); const fx = f(x / Xn), fy = f(y / Yn), fz = f(z / Zn); return [116 * fy - 16, 500 * (fx - fy), 200 * (fy - fz)]; }
        function rgbToLab(rgb) { return xyzToLab(rgbToXyz(rgb)); }
        function labToXyz([L, a, b]) { const [Xn, Yn, Zn] = [0.95047, 1.00000, 1.08883]; const fy = (L + 16) / 116, fx = a / 500 + fy, fz = fy - b / 200; const cube = t => t * t * t; const inv = t => cube(t) > 0.008856 ? cube(t) : (t - 16 / 116) / 7.787; return [Xn * inv(fx), Yn * inv(fy), Zn * inv(fz)]; }
        function xyzToRgb([x, y, z]) { let r = x * 3.2406 + y * -1.5372 + z * -0.4986, g = x * -0.9689 + y * 1.8758 + z * 0.0415, b = x * 0.0557 + y * -0.2040 + z * 1.0570; const gamma = v => v > 0.0031308 ? 1.055 * Math.pow(v, 1 / 2.4) - 0.055 : 12.92 * v; return [Math.round(Math.min(Math.max(0, gamma(r)), 1) * 255), Math.round(Math.min(Math.max(0, gamma(g)), 1) * 255), Math.round(Math.min(Math.max(0, gamma(b)), 1) * 255)]; }
        function labToRgb(lab) { return xyzToRgb(labToXyz(lab)); }
        function distanceSquaredLab(a, b) { const d0 = a[0] - b[0], d1 = a[1] - b[1], d2 = a[2] - b[2]; return d0 * d0 + d1 * d1 + d2 * d2; }
        function buildKdTree(points, depth = 0) { if (points.length === 0) return null; const axis = depth % 3; points.sort((a, b) => a.lab[axis] - b.lab[axis]); const median = Math.floor(points.length / 2); return { point: points[median], axis, left: buildKdTree(points.slice(0, median), depth + 1), right: buildKdTree(points.slice(median + 1), depth + 1) }; }
        function kdNearest(node, targetLab, best = { point: null, dist: Infinity }) { if (!node) return best; const d = distanceSquaredLab(targetLab, node.point.lab); if (d < best.dist) best = { point: node.point, dist: d }; const axis = node.axis, diff = targetLab[axis] - node.point.lab[axis]; const [nearer, farther] = diff < 0 ? [node.left, node.right] : [node.right, node.left]; best = kdNearest(nearer, targetLab, best); if (diff * diff < best.dist) best = kdNearest(farther, targetLab, best); return best; }
        function findClosestColor(color, palette) { let minDistanceSquared = Infinity, closestColor = palette[0]; for (const paletteColor of palette) { const distanceSquared = (color[0] - paletteColor[0]) ** 2 + (color[1] - paletteColor[1]) ** 2 + (color[2] - paletteColor[2]) ** 2; if (distanceSquared < minDistanceSquared) { minDistanceSquared = distanceSquared; closestColor = paletteColor; } } return closestColor; }
        function mapPixelsToPaletteKMeans(original, palette) { const newImageData = new ImageData(original.width, original.height); if (palette.length === 0) return newImageData; const originalData = original.data, newData = newImageData.data, memo = {}; for (let i = 0; i < originalData.length; i += 4) { const alpha = originalData[i + 3]; if (alpha < 128) { newData[i] = originalData[i]; newData[i + 1] = originalData[i + 1]; newData[i + 2] = originalData[i + 2]; newData[i + 3] = alpha; continue; } const r = originalData[i], g = originalData[i + 1], b = originalData[i + 2]; const key = `${r}|${g}|${b}`; let newColor = memo[key]; if (!newColor) { newColor = findClosestColor([r, g, b], palette); memo[key] = newColor; } newData[i] = newColor[0]; newData[i + 1] = newColor[1]; newData[i + 2] = newColor[2]; newData[i + 3] = alpha; } return newImageData; }
        function calculatePSNR(original, quantized) { const dataOriginal = original.data, dataQuantized = quantized.data; let mse = 0, pixelCount = 0; for (let i = 0; i < dataOriginal.length; i += 4) { if (dataOriginal[i + 3] > 128) { mse += (dataOriginal[i] - dataQuantized[i]) ** 2; mse += (dataOriginal[i + 1] - dataQuantized[i + 1]) ** 2; mse += (dataOriginal[i + 2] - dataQuantized[i + 2]) ** 2; pixelCount++; } } if (mse === 0) return Infinity; mse = mse / (pixelCount * 3); return 20 * Math.log10(255) - 10 * Math.log10(mse); }

        function displayPalette(palette) {
            paletteContainer.innerHTML = '';
            palette.forEach((color) => {
                const [r, g, b] = color;
                const hex = rgbToHex(r, g, b);
                const swatch = document.createElement('div');
                swatch.className = 'palette-swatch';
                swatch.style.backgroundColor = hex;
                swatch.dataset.r = r; swatch.dataset.g = g; swatch.dataset.b = b;
                swatch.title = `Click to edit ${hex.toUpperCase()} (or right-click to copy)`;
                swatch.innerHTML = `<span>${hex.toUpperCase()}</span>`;

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-color-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.title = `Remove color ${hex.toUpperCase()}`;
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeColorFromPalette(color);
                });
                swatch.appendChild(deleteBtn);

                swatch.addEventListener('click', (event) => {
                    event.preventDefault();
                    quantizedCanvas.classList.remove('hidden');
                    quantizedImage.classList.add('hidden');
                    quantizedCtx.putImageData(currentQuantizedImageData, 0, 0);

                    currentEditedSwatch = swatch;
                    originalColorForEditing = [parseInt(swatch.dataset.r), parseInt(swatch.dataset.g), parseInt(swatch.dataset.b)];
                    preEditImageData = new ImageData(new Uint8ClampedArray(currentQuantizedImageData.data), currentQuantizedImageData.width, currentQuantizedImageData.height);
                    latestPreviewColor = [...originalColorForEditing];
                    const currentHex = rgbToHex(...originalColorForEditing);
                    hslCurrentColorDisplay.style.backgroundColor = currentHex;
                    nativeColorPickerInCustom.value = currentHex;
                    customColorPicker.classList.remove('hidden');
                    const rect = swatch.getBoundingClientRect();
                    let pickerTop = rect.bottom + window.scrollY + 10, pickerLeft = rect.left + window.scrollX;
                    if (pickerLeft + customColorPicker.offsetWidth > window.innerWidth) pickerLeft = window.innerWidth - customColorPicker.offsetWidth - 20;
                    if (pickerLeft < 0) pickerLeft = 20;
                    if (pickerTop + customColorPicker.offsetHeight > window.innerHeight + window.scrollY) pickerTop = rect.top + window.scrollY - customColorPicker.offsetHeight - 10;
                    if (pickerTop < 0) pickerTop = 20;
                    customColorPicker.style.top = `${pickerTop}px`;
                    customColorPicker.style.left = `${pickerLeft}px`;
                    switchColorPickerTab('rgb');
                });
                swatch.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    navigator.clipboard.writeText(hex).then(() => { updateStatus(`Copied ${hex.toUpperCase()} to clipboard!`); });
                });
                paletteContainer.appendChild(swatch);
            });
        }

        function removeColorFromPalette(colorToRemove) {
            if (currentPalette.length <= 2) {
                updateStatus('Cannot have fewer than 2 colors in the palette.', true);
                return;
            }

            if (!originalImageData || !currentQuantizedImageData) {
                updateStatus('Cannot remove color without a loaded image.', true);
                return;
            }

            updateStatus(`Removing color ${rgbToHex(...colorToRemove)}...`);
            
            setTimeout(() => {
                const colorToRemoveStr = JSON.stringify(colorToRemove);
                const colorIndex = currentPalette.findIndex(p => JSON.stringify(p) === colorToRemoveStr);

                if (colorIndex > -1) {
                    currentPalette.splice(colorIndex, 1);

                    const useDithering = ditheringCheckbox.checked;
                    let remappedImageData;
                    if (useDithering) {
                        remappedImageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
                        applyErrorDiffusion(remappedImageData, currentPalette);
                    } else {
                        remappedImageData = mapPixelsToPaletteKMeans(originalImageData, currentPalette);
                    }
                    
                    updateQuantizedImageDetails(remappedImageData);
                    displayPalette(currentPalette);

                    const newColorCount = currentPalette.length;
                    sliderValueEl.textContent = newColorCount;
                    if (!isCustomPaletteActive) {
                       colorSlider.value = newColorCount;
                    }

                    updateStatus(`Color removed. New palette has ${currentPalette.length} colors.`);
                } else {
                    updateStatus('Could not find the color to remove.', true);
                }
            }, 10);
        }

        function replaceColorInImageData(imageData, oldColor, newColor) {
            const data = imageData.data;
            const [oldR, oldG, oldB] = oldColor, [newR, newG, newB] = newColor;
            for (let i = 0; i < data.length; i += 4) {
                if (data[i] === oldR && data[i + 1] === oldG && data[i + 2] === oldB) {
                    data[i] = newR; data[i + 1] = newG; data[i + 2] = newB;
                }
            }
        }

        function switchColorPickerTab(tabName) {
            if (tabName === 'rgb') {
                rgbPanel.classList.remove('hidden');
                hslPanel.classList.add('hidden');
                rgbTabBtn.classList.add('border-indigo-500', 'text-indigo-700');
                rgbTabBtn.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700');
                hslTabBtn.classList.remove('border-indigo-500', 'text-indigo-700');
                hslTabBtn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700');
                nativeColorPickerInCustom.value = rgbToHex(...latestPreviewColor);
            } else if (tabName === 'hsl') {
                rgbPanel.classList.add('hidden');
                hslPanel.classList.remove('hidden');
                hslTabBtn.classList.add('border-indigo-500', 'text-indigo-700');
                hslTabBtn.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700');
                rgbTabBtn.classList.remove('border-indigo-500', 'text-indigo-700');
                rgbTabBtn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700');
                const [h, s, l] = rgbToHsl(...latestPreviewColor);
                hslH.value = h; hslS.value = s; hslL.value = l;
                hslHValue.textContent = h; hslSValue.textContent = `${s}%`; hslLValue.textContent = `${l}%`;
                hslCurrentColorDisplay.style.backgroundColor = rgbToHex(...latestPreviewColor);
            }
        }

        function handleLivePreview(newColor) {
            if (!preEditImageData || !originalColorForEditing) return;
            const tempImageData = new ImageData(new Uint8ClampedArray(preEditImageData.data), preEditImageData.width, preEditImageData.height);
            replaceColorInImageData(tempImageData, originalColorForEditing, newColor);
            quantizedCtx.putImageData(tempImageData, 0, 0);
            latestPreviewColor = newColor;
            updateStatus(`Previewing color ${rgbToHex(...newColor)}...`);
        }

        function handleNativeColorPickerInput() { const newColor = hexToRgb(nativeColorPickerInCustom.value); hslCurrentColorDisplay.style.backgroundColor = nativeColorPickerInCustom.value; handleLivePreview(newColor); }
        function updateHslSlidersAndImage() { const h = parseInt(hslH.value), s = parseInt(hslS.value), l = parseInt(hslL.value); hslHValue.textContent = h; hslSValue.textContent = `${s}%`; hslLValue.textContent = `${l}%`; const newColor = hslToRgb(h, s, l); const hex = rgbToHex(...newColor); hslCurrentColorDisplay.style.backgroundColor = hex; nativeColorPickerInCustom.value = hex; handleLivePreview(newColor); }

        function finalizeColorChange() {
            if (!originalColorForEditing || !latestPreviewColor) return;
            replaceColorInImageData(preEditImageData, originalColorForEditing, latestPreviewColor);
            
            const oldColorStr = JSON.stringify(originalColorForEditing);
            const indexToUpdate = currentPalette.findIndex(p => JSON.stringify(p) === oldColorStr);
            if (indexToUpdate > -1) currentPalette[indexToUpdate] = latestPreviewColor;
            
            updateQuantizedImageDetails(preEditImageData);
            displayPalette(currentPalette);

            quantizedCanvas.classList.add('hidden');
            quantizedImage.classList.remove('hidden');

            updateStatus(`Color updated to ${rgbToHex(...latestPreviewColor)}.`, false);
            customColorPicker.classList.add('hidden');
            originalColorForEditing = null; latestPreviewColor = null; preEditImageData = null; currentEditedSwatch = null;
        }

        function cancelColorChange() {
            if (!preEditImageData) return;
            
            quantizedCanvas.classList.add('hidden');
            quantizedImage.classList.remove('hidden');

            updateStatus('Color change cancelled.', false);
            customColorPicker.classList.add('hidden');
            originalColorForEditing = null; latestPreviewColor = null; preEditImageData = null; currentEditedSwatch = null;
        }

        function rgbToHex(r, g, b) { return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }
        function hexToRgb(hex) {
            const hexValue = hex.startsWith('#') ? hex.slice(1) : hex;
            if (hexValue.length === 3) {
                const r = parseInt(hexValue[0] + hexValue[0], 16);
                const g = parseInt(hexValue[1] + hexValue[1], 16);
                const b = parseInt(hexValue[2] + hexValue[2], 16);
                return [r, g, b];
            } else if (hexValue.length === 6) {
                const r = parseInt(hexValue.slice(0, 2), 16);
                const g = parseInt(hexValue.slice(2, 4), 16);
                const b = parseInt(hexValue.slice(4, 6), 16);
                return [r, g, b];
            }
            return [0, 0, 0];
        }
        function rgbToHsl(r, g, b) { r /= 255; g /= 255; b /= 255; const max = Math.max(r, g, b), min = Math.min(r, g, b); let h = 0, s, l = (max + min) / 2; if (max === min) { h = s = 0; } else { const d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min); switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; } return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)]; }
        function hslToRgb(h, s, l) { h /= 360; s /= 100; l /= 100; let r, g, b; if (s === 0) { r = g = b = l; } else { const hue2rgb = (p, q, t) => { if (t < 0) t += 1; if (t > 1) t -= 1; if (t < 1 / 6) return p + (q - p) * 6 * t; if (t < 1 / 2) return q; if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6; return p; }; const q = l < 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q; r = hue2rgb(p, q, h + 1 / 3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1 / 3); } return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)]; }

        function handleExportPalette() {
            if (!currentPalette || currentPalette.length === 0) {
                updateStatus('No palette to export.', true);
                return;
            }
            const paletteText = currentPalette.map(color => rgbToHex(...color)).join('\n');
            const blob = new Blob([paletteText], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'palette.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            updateStatus('Palette exported successfully!');
        }

        async function runFullAnalysis() {
            if (!originalImageData) {
                updateStatus('Please upload an image first.', true);
                return;
            }
            setControlsEnabled(false);
            runFullAnalysisBtn.disabled = true;

            fullAnalysisResults.classList.remove('hidden');
            analysisTableBody.innerHTML = '';
            const maxColors = parseInt(colorSlider.value, 10);
            let previousPsnr = null;
            const algorithm = algorithmSelect.value;
            const useDithering = ditheringCheckbox.checked;

            isCustomPaletteActive = false;
            paletteFileNameEl.textContent = 'Upload Palette (TXT)...';


            for (let k = 2; k <= maxColors; k++) {
                updateStatus(`Analysis: Processing for ${k} colors...`);
                await new Promise(resolve => setTimeout(resolve, 10));
                try {
                    let paletteResult;
                    let finalImageData;

                    if (algorithm === 'median-cut') {
                        paletteResult = quantizeMedianCut(originalImageData, k);
                        finalImageData = mapPixelsToPaletteKMeans(originalImageData, getUniquePalette(paletteResult.palette));
                    } else if (algorithm === 'k-means') {
                        paletteResult = quantizeKMeans(originalImageData, k);
                        finalImageData = mapPixelsToPaletteKMeans(originalImageData, getUniquePalette(paletteResult.palette));
                    } else if (algorithm === 'neuquant') {
                        paletteResult = quantizeNeuQuant(originalImageData, k);
                        finalImageData = mapPixelsToPaletteKMeans(originalImageData, getUniquePalette(paletteResult.palette));
                    } else if (algorithm === 'octree') {
                        const octreeOutput = quantizeOctree(originalImageData, k);
                        paletteResult = { palette: octreeOutput.palette };
                        finalImageData = octreeOutput.quantizedData;
                    } else {
                        throw new Error('Unknown quantization algorithm selected.');
                    }
                    const uniquePalette = getUniquePalette(paletteResult.palette);

                    if (useDithering) {
                        finalImageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
                        applyErrorDiffusion(finalImageData, uniquePalette);
                    }
                    const psnr = calculatePSNR(originalImageData, finalImageData);
                    const row = analysisTableBody.insertRow();
                    row.className = 'border-b border-gray-100';
                    row.insertCell().textContent = k;
                    row.insertCell().textContent = isFinite(psnr) ? psnr.toFixed(2) : '∞';
                    const cellDelta = row.insertCell();
                    if (previousPsnr !== null && isFinite(psnr) && isFinite(previousPsnr)) {
                        const delta = psnr - previousPsnr;
                        cellDelta.textContent = delta.toFixed(2);
                        cellDelta.classList.add(delta >= 0 ? 'delta-positive' : 'delta-negative');
                    } else {
                        cellDelta.textContent = 'N/A';
                    }
                    previousPsnr = psnr;
                    analysisTableContainer.scrollTop = analysisTableContainer.scrollHeight;
                } catch (error) {
                    console.error(`Error during full analysis for ${k} colors:`, error);
                    const row = analysisTableBody.insertRow();
                    row.className = 'border-b border-gray-100 text-red-600';
                    row.insertCell().textContent = k; row.insertCell().textContent = 'Error'; row.insertCell().textContent = 'Error';
                    updateStatus(`An error occurred during analysis for ${k} colors.`, true);
                    break;
                }
            }
            updateStatus('Full analysis complete!');
            setControlsEnabled(true);
        }

        function handlePaletteUpload(file) {
            if (!file || !file.type.startsWith('text/')) {
                updateStatus('Please select a valid text file for the palette.', true);
                return;
            }
            paletteFileNameEl.textContent = file.name.length > 20 ? `${file.name.substring(0, 17)}...` : file.name;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const uploadedPalette = parsePaletteFile(event.target.result);
                    if (uploadedPalette.length === 0) {
                        updateStatus('No valid colors found in the palette file.', true);
                        return;
                    }
                    applyCustomPalette(uploadedPalette);
                    updateStatus(`Custom palette with ${uploadedPalette.length} colors loaded.`);
                } catch (error) {
                    console.error("Error parsing palette file:", error);
                    updateStatus('Error parsing palette file. Please check format.', true);
                }
            };
            reader.readAsText(file);
            paletteUpload.value = '';
        }

        function parsePaletteFile(text) {
            const lines = text.split('\n');
            const palette = [];
            lines.forEach(line => {
                line = line.trim();
                if (!line) return;

                let color = null;
                if (line.startsWith('#')) {
                    color = hexToRgb(line);
                } else if (line.length === 6 || line.length === 3) {
                    color = hexToRgb(line);
                }
                else if (line.includes(',')) {
                    const parts = line.split(',').map(p => parseInt(p.trim(), 10));
                    if (parts.length === 3 && parts.every(p => !isNaN(p) && p >= 0 && p <= 255)) {
                        color = parts;
                    }
                }

                if (color && color.every(c => !isNaN(c))) {
                    palette.push(color);
                } else {
                    console.warn(`Could not parse color: ${line}`);
                }
            });
            return palette;
        }

        function applyCustomPalette(palette) {
            if (!originalImageData) {
                updateStatus('Please upload an image first to apply a palette.', true);
                return;
            }

            isCustomPaletteActive = true;
            currentPalette = getUniquePalette(palette);

            const useDithering = ditheringCheckbox.checked;
            let mappedImageData;

            if (useDithering) {
                updateStatus('Applying dithering with custom palette...');
                mappedImageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
                applyErrorDiffusion(mappedImageData, currentPalette);
            } else {
                mappedImageData = mapPixelsToPaletteKMeans(originalImageData, currentPalette);
            }

            updateQuantizedImageDetails(mappedImageData);
            displayPalette(currentPalette);
            updateStatus(`Image mapped to custom palette with ${currentPalette.length} unique colors.`);
        }

        document.addEventListener('DOMContentLoaded', () => {
            setControlsEnabled(false);
        });

    </script>
</body>

</html>

